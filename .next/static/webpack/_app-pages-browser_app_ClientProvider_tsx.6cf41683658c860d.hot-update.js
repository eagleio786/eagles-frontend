"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_ClientProvider_tsx",{

/***/ "(app-pages-browser)/./store/watchAddress.ts":
/*!*******************************!*\
  !*** ./store/watchAddress.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _userCounterStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./userCounterStore */ \"(app-pages-browser)/./store/userCounterStore.ts\");\n/* harmony import */ var _config_exports__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/config/exports */ \"(app-pages-browser)/./config/exports.ts\");\n/* harmony import */ var _config_Method__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/config/Method */ \"(app-pages-browser)/./config/Method.ts\");\n// watchAddress.ts\n\n\n\n\n\n\n// ✅ Corrected subscribe\nconst unsub = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useAdressStore.subscribe((state)=>state.address, (address, prevAddress)=>{\n    if (address && address !== prevAddress) {\n        console.log(\"Address changed (global watcher):\", address);\n        profilefun();\n        UplinerId();\n        getEveryLevelData();\n        getEveryLevelDataX2();\n        getDashStats();\n    }\n}, {\n    fireImmediately: true\n});\nconst profilefun = async ()=>{\n    console.log(\"profile function is running\");\n    const currentAddress = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useAdressStore.getState().address;\n    const setapiresp = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().setresp;\n    const defaultProfile = {\n        id: \"\",\n        name: \"name\",\n        profileImage: \"\",\n        description: \"description\",\n        email: \"email@example.com\",\n        walletAddress: \"wallet_address\",\n        socialLinks: {\n            facebook: \"\",\n            youtube: \"\",\n            instagram: \"\",\n            twitter: \"\",\n            whatsapp: \"\"\n        }\n    };\n    try {\n        var _response_data;\n        const response = await axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].get(\"\".concat(_config_exports__WEBPACK_IMPORTED_MODULE_1__.ApiUrl, \"/user/profile/\").concat(currentAddress));\n        const profileData = (_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.data;\n        setapiresp(response);\n        console.log(response, \"reposns\");\n        if (profileData) {\n            _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useProfileStore.getState().setProfile(profileData);\n            console.log(\"✅ Profile updated:\", profileData);\n        } else {\n            console.warn(\"⚠️ No profile data found in response.\");\n        }\n    } catch (error) {\n        console.error(\"❌ Error while getting profile:\", error);\n        setapiresp(error);\n        _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useProfileStore.getState().setProfile(defaultProfile);\n    }\n};\nconst UplinerId = async ()=>{\n    const currentAddress = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useAdressStore.getState().address;\n    console.log(\"upliner id is \");\n    const setUplinerId = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useUplinerStore.getState().setUplinerId; // ✅ CORRECT\n    const SetUserId = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useUserId.getState().setUserId; // ✅ CORRECT\n    const setX1 = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useUserLevels.getState().setLvlX1;\n    const setX2 = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useUserLevels.getState().setLvlX2;\n    const setX3 = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useUserLevels.getState().setLvlX3;\n    const setTotalProfit = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().setTotalProfit;\n    const setTotalpartners = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().setpartners;\n    const setTotalTeam = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().setteam;\n    const sethr24Totalpartners = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().sethr24partners;\n    const sethr24TotalTeam = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().sethr24team;\n    try {\n        let val = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.users)(currentAddress);\n        SetUserId(Number(val[1]).toString());\n        setX1(Number(val[2]));\n        setX2(Number(val[3]));\n        let val2 = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.users)(val[0]);\n        let X3val = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.X3Users)(currentAddress);\n        let Kashif = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.getPartners)(currentAddress);\n        setX3(Number(X3val[2]));\n        let profit = Number(val[4]) + Number(X3val[3]);\n        let partner = Number(Kashif);\n        let fun18 = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.getTotalTeamCount)(currentAddress);\n        let par = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.get24HourDirects)(currentAddress);\n        let par24 = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.X3get24HourDirects)(currentAddress);\n        let tea = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.get24HourTeamCount)(currentAddress);\n        let X3tea = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.X3get24HourTeamCount)(currentAddress);\n        let partner24hr = Number(par) + Number(par24);\n        let team24hr = Number(tea) + Number(X3tea);\n        if (currentAddress === \"0x31eaCE9383eE97A5cF2FD6A1B254F27683DedE1B\") {\n            let team = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.lastUserid)();\n            let prof = profit / 1e18;\n            let prof2 = prof + 25418;\n            setTotalProfit(prof2);\n            setTotalTeam(Number(team) + 25445);\n            setTotalpartners(partner + 1289);\n            console.log(\"bakwas in if condition\", team, profit, prof2);\n        } else {\n            let team = Number(Kashif) + Number(fun18);\n            console.log(\"bakwas in else condition\", team);\n            setTotalTeam(team);\n            let prof = profit / 1e18;\n            setTotalProfit(prof);\n            setTotalpartners(partner);\n        }\n        sethr24TotalTeam(team24hr);\n        sethr24Totalpartners(partner24hr);\n        // setTotalProfit(profit);\n        console.log(\"upliner id is \", val2);\n        setUplinerId(Number(val2[1]).toString());\n    } catch (error) {\n        console.log(\"error while getting users data\", error);\n    }\n};\nconst setLevels = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useX1LevelStore.getState().setLevels; // ✅ FIXED\nconst levels = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useX1LevelStore.getState().levels;\nconst getEveryLevelData = async ()=>{\n    const currentAddress = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useAdressStore.getState().address;\n    try {\n        const updatedLevels = await Promise.all(levels.map(async (lvl)=>{\n            try {\n                console.log(\"response\", currentAddress);\n                const response = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.getSlotFilled)(currentAddress, \"1\", lvl.level.toString());\n                console.log(\"response\", response);\n                const boolres = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.isLocked)(currentAddress, \"1\", lvl.level.toString());\n                console.log(\"kas\", boolres);\n                return {\n                    ...lvl,\n                    slots: [\n                        Number(response[0]),\n                        lvl.slots[1]\n                    ],\n                    recycleCount: Number(response[1]),\n                    maxUsers: Number(response[0]) + Number(response[1]) * 4,\n                    locked: boolres\n                };\n            } catch (err) {\n                console.error(\"Error fetching level \".concat(lvl.level, \":\"), err);\n                return lvl;\n            }\n        }));\n        setLevels(updatedLevels);\n    } catch (error) {\n        console.log(\"Error while getting slots:\", error);\n    }\n};\nconst setLevelsX2 = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useX2LevelStore.getState().setLevels; // ✅ FIXED\nconst levelsX2 = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useX2LevelStore.getState().levels;\nconst getEveryLevelDataX2 = async ()=>{\n    const currentAddress = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useAdressStore.getState().address;\n    try {\n        const updatedLevels = await Promise.all(levelsX2.map(async (lvl)=>{\n            try {\n                console.log(\"response\", currentAddress);\n                const response = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.getSlotFilled)(currentAddress, \"2\", lvl.level.toString());\n                console.log(\"response\", response);\n                const boolres = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.isLocked)(currentAddress, \"2\", lvl.level.toString());\n                console.log(\"kas\", boolres);\n                return {\n                    ...lvl,\n                    slots: [\n                        Number(response[0]),\n                        lvl.slots[1]\n                    ],\n                    recycleCount: Number(response[1]),\n                    maxUsers: Number(response[0]) + Number(response[1]) * 4,\n                    locked: boolres\n                };\n            } catch (err) {\n                console.error(\"Error fetching level \".concat(lvl.level, \":\"), err);\n                return lvl;\n            }\n        }));\n        setLevelsX2(updatedLevels);\n    } catch (error) {\n        console.log(\"Error while getting slots:\", error);\n    }\n};\nconst getDashStats = async ()=>{\n    const currentAddress = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useAdressStore.getState().address;\n    const sethr24ProfitProfit = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().sethr24ProfitProfit;\n    try {\n        let val = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.get24HourPayment)(currentAddress);\n        let valX3 = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.X3get24HourPayment)(currentAddress);\n        let final = Number(val) + Number(valX3);\n        console.log(\"zzz\", final / _config_exports__WEBPACK_IMPORTED_MODULE_1__.usdtdecimals);\n        sethr24ProfitProfit(final / _config_exports__WEBPACK_IMPORTED_MODULE_1__.usdtdecimals);\n    } catch (error) {\n        console.log(\"error while getting stats\", error);\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unsub);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL3dhdGNoQWRkcmVzcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGtCQUFrQjtBQUNRO0FBT0U7QUFDNEI7QUFNNUI7QUFjSDtBQUN1QjtBQVVoRCx3QkFBd0I7QUFDeEIsTUFBTXdCLFFBQVF0Qiw2REFBY0EsQ0FBQ3VCLFNBQVMsQ0FDcEMsQ0FBQ0MsUUFBVUEsTUFBTUMsT0FBTyxFQUN4QixDQUFDQSxTQUFTQztJQUNSLElBQUlELFdBQVdBLFlBQVlDLGFBQWE7UUFDdENDLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUNIO1FBQ2pESTtRQUNBQztRQUNBQztRQUNBQztRQUNBQztJQUNGO0FBQ0YsR0FDQTtJQUNFQyxpQkFBaUI7QUFDbkI7QUFHRixNQUFNTCxhQUFhO0lBQ2pCRixRQUFRQyxHQUFHLENBQUM7SUFDWixNQUFNTyxpQkFBaUJuQyw2REFBY0EsQ0FBQ29DLFFBQVEsR0FBR1gsT0FBTztJQUN4RCxNQUFNWSxhQUFhdEMsa0VBQW1CQSxDQUFDcUMsUUFBUSxHQUFHRSxPQUFPO0lBRXpELE1BQU1DLGlCQUFpQjtRQUNyQkMsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLGNBQWM7UUFDZEMsYUFBYTtRQUNiQyxPQUFPO1FBQ1BDLGVBQWU7UUFDZkMsYUFBYTtZQUNYQyxVQUFVO1lBQ1ZDLFNBQVM7WUFDVEMsV0FBVztZQUNYQyxTQUFTO1lBQ1RDLFVBQVU7UUFDWjtJQUNGO0lBQ0EsSUFBSTtZQUlrQkM7UUFIcEIsTUFBTUEsV0FBVyxNQUFNdEQsNkNBQUtBLENBQUN1RCxHQUFHLENBQzlCLEdBQTBCbEIsT0FBdkJoQyxtREFBTUEsRUFBQyxrQkFBK0IsT0FBZmdDO1FBRTVCLE1BQU1tQixlQUFjRixpQkFBQUEsU0FBU0csSUFBSSxjQUFiSCxxQ0FBQUEsZUFBZUcsSUFBSTtRQUN2Q2xCLFdBQVdlO1FBQ1h6QixRQUFRQyxHQUFHLENBQUN3QixVQUFTO1FBQ3JCLElBQUlFLGFBQWE7WUFDZmpELDhEQUFlQSxDQUFDK0IsUUFBUSxHQUFHb0IsVUFBVSxDQUFDRjtZQUN0QzNCLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0IwQjtRQUNwQyxPQUFPO1lBQ0wzQixRQUFROEIsSUFBSSxDQUFDO1FBQ2Y7SUFDRixFQUFFLE9BQU9DLE9BQU87UUFDZC9CLFFBQVErQixLQUFLLENBQUMsa0NBQWtDQTtRQUNoRHJCLFdBQVdxQjtRQUVYckQsOERBQWVBLENBQUMrQixRQUFRLEdBQUdvQixVQUFVLENBQUNqQjtJQUN4QztBQUNGO0FBQ0EsTUFBTVQsWUFBWTtJQUNoQixNQUFNSyxpQkFBaUJuQyw2REFBY0EsQ0FBQ29DLFFBQVEsR0FBR1gsT0FBTztJQUV4REUsUUFBUUMsR0FBRyxDQUFDO0lBQ1osTUFBTStCLGVBQWVyRCw4REFBZUEsQ0FBQzhCLFFBQVEsR0FBR3VCLFlBQVksRUFBRSxZQUFZO0lBQzFFLE1BQU1DLFlBQVkzRCx3REFBU0EsQ0FBQ21DLFFBQVEsR0FBR3lCLFNBQVMsRUFBRSxZQUFZO0lBQzlELE1BQU1DLFFBQVE1RCw0REFBYUEsQ0FBQ2tDLFFBQVEsR0FBRzJCLFFBQVE7SUFDL0MsTUFBTUMsUUFBUTlELDREQUFhQSxDQUFDa0MsUUFBUSxHQUFHNkIsUUFBUTtJQUMvQyxNQUFNQyxRQUFRaEUsNERBQWFBLENBQUNrQyxRQUFRLEdBQUcrQixRQUFRO0lBQy9DLE1BQU1DLGlCQUFpQnJFLGtFQUFtQkEsQ0FBQ3FDLFFBQVEsR0FBR2dDLGNBQWM7SUFDcEUsTUFBTUMsbUJBQW1CdEUsa0VBQW1CQSxDQUFDcUMsUUFBUSxHQUFHa0MsV0FBVztJQUNuRSxNQUFNQyxlQUFleEUsa0VBQW1CQSxDQUFDcUMsUUFBUSxHQUFHb0MsT0FBTztJQUMzRCxNQUFNQyx1QkFBdUIxRSxrRUFBbUJBLENBQUNxQyxRQUFRLEdBQUdzQyxlQUFlO0lBQzNFLE1BQU1DLG1CQUFtQjVFLGtFQUFtQkEsQ0FBQ3FDLFFBQVEsR0FBR3dDLFdBQVc7SUFFbkUsSUFBSTtRQUNGLElBQUlDLE1BQU8sTUFBTTdELHFEQUFLQSxDQUFDbUI7UUFTdkJ5QixVQUFVa0IsT0FBT0QsR0FBRyxDQUFDLEVBQUUsRUFBRUUsUUFBUTtRQUNqQ2pCLE1BQU1nQixPQUFPRCxHQUFHLENBQUMsRUFBRTtRQUNuQmIsTUFBTWMsT0FBT0QsR0FBRyxDQUFDLEVBQUU7UUFFbkIsSUFBSUcsT0FBUSxNQUFNaEUscURBQUtBLENBQUM2RCxHQUFHLENBQUMsRUFBRTtRQVM5QixJQUFJSSxRQUFTLE1BQU03RCx1REFBT0EsQ0FBQ2U7UUFRM0IsSUFBSStDLFNBQVUsTUFBTXRFLDJEQUFXQSxDQUFDdUI7UUFDaEMrQixNQUFNWSxPQUFPRyxLQUFLLENBQUMsRUFBRTtRQUNyQixJQUFJRSxTQUFTTCxPQUFPRCxHQUFHLENBQUMsRUFBRSxJQUFJQyxPQUFPRyxLQUFLLENBQUMsRUFBRTtRQUM3QyxJQUFJRyxVQUFVTixPQUFPSTtRQUNyQixJQUFJRyxRQUFRLE1BQU14RSxpRUFBaUJBLENBQUNzQjtRQUNwQyxJQUFJbUQsTUFBTSxNQUFNN0UsZ0VBQWdCQSxDQUFDMEI7UUFDakMsSUFBSW9ELFFBQVEsTUFBTXRFLGtFQUFrQkEsQ0FBQ2tCO1FBQ3JDLElBQUlxRCxNQUFNLE1BQU03RSxrRUFBa0JBLENBQUN3QjtRQUNuQyxJQUFJc0QsUUFBUSxNQUFNdEUsb0VBQW9CQSxDQUFDZ0I7UUFDdkMsSUFBSXVELGNBQWNaLE9BQU9RLE9BQU9SLE9BQU9TO1FBQ3ZDLElBQUlJLFdBQVdiLE9BQU9VLE9BQU9WLE9BQU9XO1FBQ3BDLElBQUl0RCxtQkFBbUIsOENBQThDO1lBQ25FLElBQUl5RCxPQUFRLE1BQU03RSwwREFBVUE7WUFDNUIsSUFBSThFLE9BQU9WLFNBQVM7WUFDcEIsSUFBSVcsUUFBUUQsT0FBTztZQUVuQnpCLGVBQWUwQjtZQUNmdkIsYUFBYU8sT0FBT2MsUUFBUTtZQUM1QnZCLGlCQUFpQmUsVUFBVTtZQUMzQnpELFFBQVFDLEdBQUcsQ0FBQywwQkFBMEJnRSxNQUFNVCxRQUFRVztRQUN0RCxPQUFPO1lBQ0wsSUFBSUYsT0FBT2QsT0FBT0ksVUFBVUosT0FBT087WUFDbkMxRCxRQUFRQyxHQUFHLENBQUMsNEJBQTRCZ0U7WUFDeENyQixhQUFhcUI7WUFDYixJQUFJQyxPQUFPVixTQUFTO1lBQ3BCZixlQUFleUI7WUFDZnhCLGlCQUFpQmU7UUFDbkI7UUFDQVQsaUJBQWlCZ0I7UUFDakJsQixxQkFBcUJpQjtRQUVyQiwwQkFBMEI7UUFDMUIvRCxRQUFRQyxHQUFHLENBQUMsa0JBQWtCb0Q7UUFDOUJyQixhQUFhbUIsT0FBT0UsSUFBSSxDQUFDLEVBQUUsRUFBRUQsUUFBUTtJQUN2QyxFQUFFLE9BQU9yQixPQUFPO1FBQ2QvQixRQUFRQyxHQUFHLENBQUMsa0NBQWtDOEI7SUFDaEQ7QUFDRjtBQUNBLE1BQU1xQyxZQUFZeEYsOERBQWVBLENBQUM2QixRQUFRLEdBQUcyRCxTQUFTLEVBQUUsVUFBVTtBQUNsRSxNQUFNQyxTQUFTekYsOERBQWVBLENBQUM2QixRQUFRLEdBQUc0RCxNQUFNO0FBRWhELE1BQU1qRSxvQkFBb0I7SUFDeEIsTUFBTUksaUJBQWlCbkMsNkRBQWNBLENBQUNvQyxRQUFRLEdBQUdYLE9BQU87SUFFeEQsSUFBSTtRQUNGLE1BQU13RSxnQkFBeUIsTUFBTUMsUUFBUUMsR0FBRyxDQUM5Q0gsT0FBT0ksR0FBRyxDQUFDLE9BQU9DO1lBQ2hCLElBQUk7Z0JBQ0YxRSxRQUFRQyxHQUFHLENBQUMsWUFBWU87Z0JBQ3hCLE1BQU1pQixXQUFZLE1BQU0vQiw2REFBYUEsQ0FDbkNjLGdCQUNBLEtBQ0FrRSxJQUFJQyxLQUFLLENBQUN2QixRQUFRO2dCQUVwQnBELFFBQVFDLEdBQUcsQ0FBQyxZQUFZd0I7Z0JBQ3hCLE1BQU1tRCxVQUFXLE1BQU16Rix3REFBUUEsQ0FDN0JxQixnQkFDQSxLQUNBa0UsSUFBSUMsS0FBSyxDQUFDdkIsUUFBUTtnQkFFcEJwRCxRQUFRQyxHQUFHLENBQUMsT0FBTzJFO2dCQUVuQixPQUFPO29CQUNMLEdBQUdGLEdBQUc7b0JBQ05HLE9BQU87d0JBQUMxQixPQUFPMUIsUUFBUSxDQUFDLEVBQUU7d0JBQUdpRCxJQUFJRyxLQUFLLENBQUMsRUFBRTtxQkFBQztvQkFDMUNDLGNBQWMzQixPQUFPMUIsUUFBUSxDQUFDLEVBQUU7b0JBQ2hDc0QsVUFBVTVCLE9BQU8xQixRQUFRLENBQUMsRUFBRSxJQUFJMEIsT0FBTzFCLFFBQVEsQ0FBQyxFQUFFLElBQUk7b0JBQ3REdUQsUUFBUUo7Z0JBQ1Y7WUFDRixFQUFFLE9BQU9LLEtBQUs7Z0JBQ1pqRixRQUFRK0IsS0FBSyxDQUFDLHdCQUFrQyxPQUFWMkMsSUFBSUMsS0FBSyxFQUFDLE1BQUlNO2dCQUNwRCxPQUFPUDtZQUNUO1FBQ0Y7UUFHRk4sVUFBVUU7SUFDWixFQUFFLE9BQU92QyxPQUFPO1FBQ2QvQixRQUFRQyxHQUFHLENBQUMsOEJBQThCOEI7SUFDNUM7QUFDRjtBQUNBLE1BQU1tRCxjQUFjckcsOERBQWVBLENBQUM0QixRQUFRLEdBQUcyRCxTQUFTLEVBQUUsVUFBVTtBQUNwRSxNQUFNZSxXQUFXdEcsOERBQWVBLENBQUM0QixRQUFRLEdBQUc0RCxNQUFNO0FBRWxELE1BQU1oRSxzQkFBc0I7SUFDMUIsTUFBTUcsaUJBQWlCbkMsNkRBQWNBLENBQUNvQyxRQUFRLEdBQUdYLE9BQU87SUFFeEQsSUFBSTtRQUNGLE1BQU13RSxnQkFBeUIsTUFBTUMsUUFBUUMsR0FBRyxDQUM5Q1csU0FBU1YsR0FBRyxDQUFDLE9BQU9DO1lBQ2xCLElBQUk7Z0JBQ0YxRSxRQUFRQyxHQUFHLENBQUMsWUFBWU87Z0JBQ3hCLE1BQU1pQixXQUFZLE1BQU0vQiw2REFBYUEsQ0FDbkNjLGdCQUNBLEtBQ0FrRSxJQUFJQyxLQUFLLENBQUN2QixRQUFRO2dCQUVwQnBELFFBQVFDLEdBQUcsQ0FBQyxZQUFZd0I7Z0JBQ3hCLE1BQU1tRCxVQUFXLE1BQU16Rix3REFBUUEsQ0FDN0JxQixnQkFDQSxLQUNBa0UsSUFBSUMsS0FBSyxDQUFDdkIsUUFBUTtnQkFFcEJwRCxRQUFRQyxHQUFHLENBQUMsT0FBTzJFO2dCQUVuQixPQUFPO29CQUNMLEdBQUdGLEdBQUc7b0JBQ05HLE9BQU87d0JBQUMxQixPQUFPMUIsUUFBUSxDQUFDLEVBQUU7d0JBQUdpRCxJQUFJRyxLQUFLLENBQUMsRUFBRTtxQkFBQztvQkFDMUNDLGNBQWMzQixPQUFPMUIsUUFBUSxDQUFDLEVBQUU7b0JBQ2hDc0QsVUFBVTVCLE9BQU8xQixRQUFRLENBQUMsRUFBRSxJQUFJMEIsT0FBTzFCLFFBQVEsQ0FBQyxFQUFFLElBQUk7b0JBQ3REdUQsUUFBUUo7Z0JBQ1Y7WUFDRixFQUFFLE9BQU9LLEtBQUs7Z0JBQ1pqRixRQUFRK0IsS0FBSyxDQUFDLHdCQUFrQyxPQUFWMkMsSUFBSUMsS0FBSyxFQUFDLE1BQUlNO2dCQUNwRCxPQUFPUDtZQUNUO1FBQ0Y7UUFHRlEsWUFBWVo7SUFDZCxFQUFFLE9BQU92QyxPQUFPO1FBQ2QvQixRQUFRQyxHQUFHLENBQUMsOEJBQThCOEI7SUFDNUM7QUFDRjtBQUVBLE1BQU16QixlQUFlO0lBQ25CLE1BQU1FLGlCQUFpQm5DLDZEQUFjQSxDQUFDb0MsUUFBUSxHQUFHWCxPQUFPO0lBQ3hELE1BQU1zRixzQkFDSmhILGtFQUFtQkEsQ0FBQ3FDLFFBQVEsR0FBRzJFLG1CQUFtQjtJQUNwRCxJQUFJO1FBQ0YsSUFBSWxDLE1BQU0sTUFBTW5FLGdFQUFnQkEsQ0FBQ3lCO1FBQ2pDLElBQUk2RSxRQUFRLE1BQU05RixrRUFBa0JBLENBQUNpQjtRQUNyQyxJQUFJOEUsUUFBUW5DLE9BQU9ELE9BQU9DLE9BQU9rQztRQUNqQ3JGLFFBQVFDLEdBQUcsQ0FBQyxPQUFPcUYsUUFBUTdHLHlEQUFZQTtRQUV2QzJHLG9CQUFvQkUsUUFBUTdHLHlEQUFZQTtJQUMxQyxFQUFFLE9BQU9zRCxPQUFPO1FBQ2QvQixRQUFRQyxHQUFHLENBQUMsNkJBQTZCOEI7SUFDM0M7QUFDRjtBQUVBLGlFQUFlcEMsS0FBS0EsRUFBQyIsInNvdXJjZXMiOlsiL2hvbWUva2FzaGlmL0RvY3VtZW50cy9rYXNoaWYvZGVwbG95bWVudC9lYWdsZXMtZnJvbnRlbmQvc3RvcmUvd2F0Y2hBZGRyZXNzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHdhdGNoQWRkcmVzcy50c1xuaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IHtcbiAgZGFzaGJvYXJkU3RhdHNTdG9yZSxcbiAgdXNlQWRyZXNzU3RvcmUsXG4gIHVzZVN0YXRzU3RvcmUsXG4gIHVzZVVzZXJJZCxcbiAgdXNlVXNlckxldmVscyxcbn0gZnJvbSBcIi4vdXNlckNvdW50ZXJTdG9yZVwiO1xuaW1wb3J0IHsgQXBpVXJsLCB1c2R0ZGVjaW1hbHMgfSBmcm9tIFwiQC9jb25maWcvZXhwb3J0c1wiO1xuaW1wb3J0IHtcbiAgdXNlUHJvZmlsZVN0b3JlLFxuICB1c2VVcGxpbmVyU3RvcmUsXG4gIHVzZVgxTGV2ZWxTdG9yZSxcbiAgdXNlWDJMZXZlbFN0b3JlLFxufSBmcm9tIFwiLi91c2VyQ291bnRlclN0b3JlXCI7XG5pbXBvcnQge1xuICBnZXQyNEhvdXJEaXJlY3RzLFxuICBnZXQyNEhvdXJQYXltZW50LFxuICBnZXQyNEhvdXJUZWFtQ291bnQsXG4gIGdldFBhcnRuZXJzLFxuICBnZXRUb3RhbFRlYW1Db3VudCxcbiAgaXNMb2NrZWQsXG4gIGxhc3RVc2VyaWQsXG4gIHVzZXJzLFxuICBYM2dldDI0SG91ckRpcmVjdHMsXG4gIFgzZ2V0MjRIb3VyUGF5bWVudCxcbiAgWDNnZXQyNEhvdXJUZWFtQ291bnQsXG4gIFgzVXNlcnMsXG59IGZyb20gXCJAL2NvbmZpZy9NZXRob2RcIjtcbmltcG9ydCB7IGdldFNsb3RGaWxsZWQgfSBmcm9tIFwiQC9jb25maWcvTWV0aG9kXCI7XG5pbnRlcmZhY2UgTGV2ZWwge1xuICBsZXZlbDogbnVtYmVyO1xuICBjb3N0OiBudW1iZXI7XG4gIHNsb3RzOiBbbnVtYmVyLCBudW1iZXJdOyAvLyBbZmlsbGVkLCByZWN5Y2xlZF1cbiAgbWF4VXNlcnM6IG51bWJlcjtcbiAgcmVjeWNsZUNvdW50OiBudW1iZXI7XG4gIG5hbWU6IHN0cmluZztcbiAgbG9ja2VkOiBib29sZWFuO1xufVxuLy8g4pyFIENvcnJlY3RlZCBzdWJzY3JpYmVcbmNvbnN0IHVuc3ViID0gdXNlQWRyZXNzU3RvcmUuc3Vic2NyaWJlKFxuICAoc3RhdGUpID0+IHN0YXRlLmFkZHJlc3MsXG4gIChhZGRyZXNzLCBwcmV2QWRkcmVzcykgPT4ge1xuICAgIGlmIChhZGRyZXNzICYmIGFkZHJlc3MgIT09IHByZXZBZGRyZXNzKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkFkZHJlc3MgY2hhbmdlZCAoZ2xvYmFsIHdhdGNoZXIpOlwiLCBhZGRyZXNzKTtcbiAgICAgIHByb2ZpbGVmdW4oKTtcbiAgICAgIFVwbGluZXJJZCgpO1xuICAgICAgZ2V0RXZlcnlMZXZlbERhdGEoKTtcbiAgICAgIGdldEV2ZXJ5TGV2ZWxEYXRhWDIoKTtcbiAgICAgIGdldERhc2hTdGF0cygpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGZpcmVJbW1lZGlhdGVseTogdHJ1ZSwgLy8gcnVuIG9uIGZpcnN0IGxvYWQgaWYgdmFsdWUgaXMgbm9uLW51bGxcbiAgfVxuKTtcblxuY29uc3QgcHJvZmlsZWZ1biA9IGFzeW5jICgpID0+IHtcbiAgY29uc29sZS5sb2coXCJwcm9maWxlIGZ1bmN0aW9uIGlzIHJ1bm5pbmdcIik7XG4gIGNvbnN0IGN1cnJlbnRBZGRyZXNzID0gdXNlQWRyZXNzU3RvcmUuZ2V0U3RhdGUoKS5hZGRyZXNzO1xuICBjb25zdCBzZXRhcGlyZXNwID0gZGFzaGJvYXJkU3RhdHNTdG9yZS5nZXRTdGF0ZSgpLnNldHJlc3A7XG5cbiAgY29uc3QgZGVmYXVsdFByb2ZpbGUgPSB7XG4gICAgaWQ6IFwiXCIsXG4gICAgbmFtZTogXCJuYW1lXCIsXG4gICAgcHJvZmlsZUltYWdlOiBcIlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcImRlc2NyaXB0aW9uXCIsXG4gICAgZW1haWw6IFwiZW1haWxAZXhhbXBsZS5jb21cIixcbiAgICB3YWxsZXRBZGRyZXNzOiBcIndhbGxldF9hZGRyZXNzXCIsXG4gICAgc29jaWFsTGlua3M6IHtcbiAgICAgIGZhY2Vib29rOiBcIlwiLFxuICAgICAgeW91dHViZTogXCJcIixcbiAgICAgIGluc3RhZ3JhbTogXCJcIixcbiAgICAgIHR3aXR0ZXI6IFwiXCIsXG4gICAgICB3aGF0c2FwcDogXCJcIixcbiAgICB9LFxuICB9O1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgICAgYCR7QXBpVXJsfS91c2VyL3Byb2ZpbGUvJHtjdXJyZW50QWRkcmVzc31gXG4gICAgKTtcbiAgICBjb25zdCBwcm9maWxlRGF0YSA9IHJlc3BvbnNlLmRhdGE/LmRhdGE7XG4gICAgc2V0YXBpcmVzcChyZXNwb25zZSBhcyBhbnkpO1xuICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLFwicmVwb3Nuc1wiKVxuICAgIGlmIChwcm9maWxlRGF0YSkge1xuICAgICAgdXNlUHJvZmlsZVN0b3JlLmdldFN0YXRlKCkuc2V0UHJvZmlsZShwcm9maWxlRGF0YSk7XG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBQcm9maWxlIHVwZGF0ZWQ6XCIsIHByb2ZpbGVEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIHByb2ZpbGUgZGF0YSBmb3VuZCBpbiByZXNwb25zZS5cIik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3Igd2hpbGUgZ2V0dGluZyBwcm9maWxlOlwiLCBlcnJvcik7XG4gICAgc2V0YXBpcmVzcChlcnJvciBhcyBhbnkpO1xuXG4gICAgdXNlUHJvZmlsZVN0b3JlLmdldFN0YXRlKCkuc2V0UHJvZmlsZShkZWZhdWx0UHJvZmlsZSk7XG4gIH1cbn07XG5jb25zdCBVcGxpbmVySWQgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRBZGRyZXNzID0gdXNlQWRyZXNzU3RvcmUuZ2V0U3RhdGUoKS5hZGRyZXNzO1xuXG4gIGNvbnNvbGUubG9nKFwidXBsaW5lciBpZCBpcyBcIik7XG4gIGNvbnN0IHNldFVwbGluZXJJZCA9IHVzZVVwbGluZXJTdG9yZS5nZXRTdGF0ZSgpLnNldFVwbGluZXJJZDsgLy8g4pyFIENPUlJFQ1RcbiAgY29uc3QgU2V0VXNlcklkID0gdXNlVXNlcklkLmdldFN0YXRlKCkuc2V0VXNlcklkOyAvLyDinIUgQ09SUkVDVFxuICBjb25zdCBzZXRYMSA9IHVzZVVzZXJMZXZlbHMuZ2V0U3RhdGUoKS5zZXRMdmxYMTtcbiAgY29uc3Qgc2V0WDIgPSB1c2VVc2VyTGV2ZWxzLmdldFN0YXRlKCkuc2V0THZsWDI7XG4gIGNvbnN0IHNldFgzID0gdXNlVXNlckxldmVscy5nZXRTdGF0ZSgpLnNldEx2bFgzO1xuICBjb25zdCBzZXRUb3RhbFByb2ZpdCA9IGRhc2hib2FyZFN0YXRzU3RvcmUuZ2V0U3RhdGUoKS5zZXRUb3RhbFByb2ZpdDtcbiAgY29uc3Qgc2V0VG90YWxwYXJ0bmVycyA9IGRhc2hib2FyZFN0YXRzU3RvcmUuZ2V0U3RhdGUoKS5zZXRwYXJ0bmVycztcbiAgY29uc3Qgc2V0VG90YWxUZWFtID0gZGFzaGJvYXJkU3RhdHNTdG9yZS5nZXRTdGF0ZSgpLnNldHRlYW07XG4gIGNvbnN0IHNldGhyMjRUb3RhbHBhcnRuZXJzID0gZGFzaGJvYXJkU3RhdHNTdG9yZS5nZXRTdGF0ZSgpLnNldGhyMjRwYXJ0bmVycztcbiAgY29uc3Qgc2V0aHIyNFRvdGFsVGVhbSA9IGRhc2hib2FyZFN0YXRzU3RvcmUuZ2V0U3RhdGUoKS5zZXRocjI0dGVhbTtcblxuICB0cnkge1xuICAgIGxldCB2YWwgPSAoYXdhaXQgdXNlcnMoY3VycmVudEFkZHJlc3MpKSBhcyBbXG4gICAgICBzdHJpbmcsXG4gICAgICBCaWdJbnQsXG4gICAgICBCaWdJbnQsXG4gICAgICBCaWdJbnQsXG4gICAgICBCaWdJbnQsXG4gICAgICBCaWdJbnQsXG4gICAgICBCaWdJbnRcbiAgICBdO1xuICAgIFNldFVzZXJJZChOdW1iZXIodmFsWzFdKS50b1N0cmluZygpKTtcbiAgICBzZXRYMShOdW1iZXIodmFsWzJdKSk7XG4gICAgc2V0WDIoTnVtYmVyKHZhbFszXSkpO1xuXG4gICAgbGV0IHZhbDIgPSAoYXdhaXQgdXNlcnModmFsWzBdKSkgYXMgW1xuICAgICAgc3RyaW5nLFxuICAgICAgQmlnSW50LFxuICAgICAgQmlnSW50LFxuICAgICAgQmlnSW50LFxuICAgICAgQmlnSW50LFxuICAgICAgQmlnSW50LFxuICAgICAgQmlnSW50XG4gICAgXTtcbiAgICBsZXQgWDN2YWwgPSAoYXdhaXQgWDNVc2VycyhjdXJyZW50QWRkcmVzcykpIGFzIFtcbiAgICAgIHN0cmluZyxcbiAgICAgIEJpZ0ludCxcbiAgICAgIEJpZ0ludCxcbiAgICAgIEJpZ0ludCxcbiAgICAgIEJpZ0ludCxcbiAgICAgIEJpZ0ludFxuICAgIF07XG4gICAgbGV0IEthc2hpZiA9IChhd2FpdCBnZXRQYXJ0bmVycyhjdXJyZW50QWRkcmVzcykpIGFzIG51bWJlcjtcbiAgICBzZXRYMyhOdW1iZXIoWDN2YWxbMl0pKTtcbiAgICBsZXQgcHJvZml0ID0gTnVtYmVyKHZhbFs0XSkgKyBOdW1iZXIoWDN2YWxbM10pO1xuICAgIGxldCBwYXJ0bmVyID0gTnVtYmVyKEthc2hpZik7XG4gICAgbGV0IGZ1bjE4ID0gYXdhaXQgZ2V0VG90YWxUZWFtQ291bnQoY3VycmVudEFkZHJlc3MpO1xuICAgIGxldCBwYXIgPSBhd2FpdCBnZXQyNEhvdXJEaXJlY3RzKGN1cnJlbnRBZGRyZXNzKTtcbiAgICBsZXQgcGFyMjQgPSBhd2FpdCBYM2dldDI0SG91ckRpcmVjdHMoY3VycmVudEFkZHJlc3MpO1xuICAgIGxldCB0ZWEgPSBhd2FpdCBnZXQyNEhvdXJUZWFtQ291bnQoY3VycmVudEFkZHJlc3MpO1xuICAgIGxldCBYM3RlYSA9IGF3YWl0IFgzZ2V0MjRIb3VyVGVhbUNvdW50KGN1cnJlbnRBZGRyZXNzKTtcbiAgICBsZXQgcGFydG5lcjI0aHIgPSBOdW1iZXIocGFyKSArIE51bWJlcihwYXIyNCk7XG4gICAgbGV0IHRlYW0yNGhyID0gTnVtYmVyKHRlYSkgKyBOdW1iZXIoWDN0ZWEpO1xuICAgIGlmIChjdXJyZW50QWRkcmVzcyA9PT0gXCIweDMxZWFDRTkzODNlRTk3QTVjRjJGRDZBMUIyNTRGMjc2ODNEZWRFMUJcIikge1xuICAgICAgbGV0IHRlYW0gPSAoYXdhaXQgbGFzdFVzZXJpZCgpKSBhcyBiaWdpbnQ7XG4gICAgICBsZXQgcHJvZiA9IHByb2ZpdCAvIDFlMTg7XG4gICAgICBsZXQgcHJvZjIgPSBwcm9mICsgMjU0MTg7XG5cbiAgICAgIHNldFRvdGFsUHJvZml0KHByb2YyKTtcbiAgICAgIHNldFRvdGFsVGVhbShOdW1iZXIodGVhbSkgKyAyNTQ0NSk7XG4gICAgICBzZXRUb3RhbHBhcnRuZXJzKHBhcnRuZXIgKyAxMjg5KTtcbiAgICAgIGNvbnNvbGUubG9nKFwiYmFrd2FzIGluIGlmIGNvbmRpdGlvblwiLCB0ZWFtLCBwcm9maXQsIHByb2YyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRlYW0gPSBOdW1iZXIoS2FzaGlmKSArIE51bWJlcihmdW4xOCk7XG4gICAgICBjb25zb2xlLmxvZyhcImJha3dhcyBpbiBlbHNlIGNvbmRpdGlvblwiLCB0ZWFtKTtcbiAgICAgIHNldFRvdGFsVGVhbSh0ZWFtKTtcbiAgICAgIGxldCBwcm9mID0gcHJvZml0IC8gMWUxODtcbiAgICAgIHNldFRvdGFsUHJvZml0KHByb2YpO1xuICAgICAgc2V0VG90YWxwYXJ0bmVycyhwYXJ0bmVyKTtcbiAgICB9XG4gICAgc2V0aHIyNFRvdGFsVGVhbSh0ZWFtMjRocik7XG4gICAgc2V0aHIyNFRvdGFscGFydG5lcnMocGFydG5lcjI0aHIpO1xuXG4gICAgLy8gc2V0VG90YWxQcm9maXQocHJvZml0KTtcbiAgICBjb25zb2xlLmxvZyhcInVwbGluZXIgaWQgaXMgXCIsIHZhbDIpO1xuICAgIHNldFVwbGluZXJJZChOdW1iZXIodmFsMlsxXSkudG9TdHJpbmcoKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5sb2coXCJlcnJvciB3aGlsZSBnZXR0aW5nIHVzZXJzIGRhdGFcIiwgZXJyb3IpO1xuICB9XG59O1xuY29uc3Qgc2V0TGV2ZWxzID0gdXNlWDFMZXZlbFN0b3JlLmdldFN0YXRlKCkuc2V0TGV2ZWxzOyAvLyDinIUgRklYRURcbmNvbnN0IGxldmVscyA9IHVzZVgxTGV2ZWxTdG9yZS5nZXRTdGF0ZSgpLmxldmVscztcblxuY29uc3QgZ2V0RXZlcnlMZXZlbERhdGEgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRBZGRyZXNzID0gdXNlQWRyZXNzU3RvcmUuZ2V0U3RhdGUoKS5hZGRyZXNzO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgdXBkYXRlZExldmVsczogTGV2ZWxbXSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgbGV2ZWxzLm1hcChhc3luYyAobHZsKTogUHJvbWlzZTxMZXZlbD4gPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVzcG9uc2VcIiwgY3VycmVudEFkZHJlc3MpO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IGdldFNsb3RGaWxsZWQoXG4gICAgICAgICAgICBjdXJyZW50QWRkcmVzcyxcbiAgICAgICAgICAgIFwiMVwiLFxuICAgICAgICAgICAgbHZsLmxldmVsLnRvU3RyaW5nKClcbiAgICAgICAgICApKSBhcyBbYmlnaW50LCBiaWdpbnRdO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVzcG9uc2VcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgIGNvbnN0IGJvb2xyZXMgPSAoYXdhaXQgaXNMb2NrZWQoXG4gICAgICAgICAgICBjdXJyZW50QWRkcmVzcyxcbiAgICAgICAgICAgIFwiMVwiLFxuICAgICAgICAgICAgbHZsLmxldmVsLnRvU3RyaW5nKClcbiAgICAgICAgICApKSBhcyBib29sZWFuO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwia2FzXCIsIGJvb2xyZXMpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmx2bCxcbiAgICAgICAgICAgIHNsb3RzOiBbTnVtYmVyKHJlc3BvbnNlWzBdKSwgbHZsLnNsb3RzWzFdXSBhcyBbbnVtYmVyLCBudW1iZXJdLCAvLyDwn5GIIGZpeCBoZXJlXG4gICAgICAgICAgICByZWN5Y2xlQ291bnQ6IE51bWJlcihyZXNwb25zZVsxXSksXG4gICAgICAgICAgICBtYXhVc2VyczogTnVtYmVyKHJlc3BvbnNlWzBdKSArIE51bWJlcihyZXNwb25zZVsxXSkgKiA0LFxuICAgICAgICAgICAgbG9ja2VkOiBib29scmVzLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGxldmVsICR7bHZsLmxldmVsfTpgLCBlcnIpO1xuICAgICAgICAgIHJldHVybiBsdmw7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHNldExldmVscyh1cGRhdGVkTGV2ZWxzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZyhcIkVycm9yIHdoaWxlIGdldHRpbmcgc2xvdHM6XCIsIGVycm9yKTtcbiAgfVxufTtcbmNvbnN0IHNldExldmVsc1gyID0gdXNlWDJMZXZlbFN0b3JlLmdldFN0YXRlKCkuc2V0TGV2ZWxzOyAvLyDinIUgRklYRURcbmNvbnN0IGxldmVsc1gyID0gdXNlWDJMZXZlbFN0b3JlLmdldFN0YXRlKCkubGV2ZWxzO1xuXG5jb25zdCBnZXRFdmVyeUxldmVsRGF0YVgyID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCBjdXJyZW50QWRkcmVzcyA9IHVzZUFkcmVzc1N0b3JlLmdldFN0YXRlKCkuYWRkcmVzcztcblxuICB0cnkge1xuICAgIGNvbnN0IHVwZGF0ZWRMZXZlbHM6IExldmVsW10gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGxldmVsc1gyLm1hcChhc3luYyAobHZsKTogUHJvbWlzZTxMZXZlbD4gPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVzcG9uc2VcIiwgY3VycmVudEFkZHJlc3MpO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IGdldFNsb3RGaWxsZWQoXG4gICAgICAgICAgICBjdXJyZW50QWRkcmVzcyxcbiAgICAgICAgICAgIFwiMlwiLFxuICAgICAgICAgICAgbHZsLmxldmVsLnRvU3RyaW5nKClcbiAgICAgICAgICApKSBhcyBbYmlnaW50LCBiaWdpbnRdO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVzcG9uc2VcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgIGNvbnN0IGJvb2xyZXMgPSAoYXdhaXQgaXNMb2NrZWQoXG4gICAgICAgICAgICBjdXJyZW50QWRkcmVzcyxcbiAgICAgICAgICAgIFwiMlwiLFxuICAgICAgICAgICAgbHZsLmxldmVsLnRvU3RyaW5nKClcbiAgICAgICAgICApKSBhcyBib29sZWFuO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwia2FzXCIsIGJvb2xyZXMpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmx2bCxcbiAgICAgICAgICAgIHNsb3RzOiBbTnVtYmVyKHJlc3BvbnNlWzBdKSwgbHZsLnNsb3RzWzFdXSBhcyBbbnVtYmVyLCBudW1iZXJdLCAvLyDwn5GIIGZpeCBoZXJlXG4gICAgICAgICAgICByZWN5Y2xlQ291bnQ6IE51bWJlcihyZXNwb25zZVsxXSksXG4gICAgICAgICAgICBtYXhVc2VyczogTnVtYmVyKHJlc3BvbnNlWzBdKSArIE51bWJlcihyZXNwb25zZVsxXSkgKiA0LFxuICAgICAgICAgICAgbG9ja2VkOiBib29scmVzLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGxldmVsICR7bHZsLmxldmVsfTpgLCBlcnIpO1xuICAgICAgICAgIHJldHVybiBsdmw7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHNldExldmVsc1gyKHVwZGF0ZWRMZXZlbHMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUubG9nKFwiRXJyb3Igd2hpbGUgZ2V0dGluZyBzbG90czpcIiwgZXJyb3IpO1xuICB9XG59O1xuXG5jb25zdCBnZXREYXNoU3RhdHMgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRBZGRyZXNzID0gdXNlQWRyZXNzU3RvcmUuZ2V0U3RhdGUoKS5hZGRyZXNzO1xuICBjb25zdCBzZXRocjI0UHJvZml0UHJvZml0ID1cbiAgICBkYXNoYm9hcmRTdGF0c1N0b3JlLmdldFN0YXRlKCkuc2V0aHIyNFByb2ZpdFByb2ZpdDtcbiAgdHJ5IHtcbiAgICBsZXQgdmFsID0gYXdhaXQgZ2V0MjRIb3VyUGF5bWVudChjdXJyZW50QWRkcmVzcyk7XG4gICAgbGV0IHZhbFgzID0gYXdhaXQgWDNnZXQyNEhvdXJQYXltZW50KGN1cnJlbnRBZGRyZXNzKTtcbiAgICBsZXQgZmluYWwgPSBOdW1iZXIodmFsKSArIE51bWJlcih2YWxYMyk7XG4gICAgY29uc29sZS5sb2coXCJ6enpcIiwgZmluYWwgLyB1c2R0ZGVjaW1hbHMpO1xuXG4gICAgc2V0aHIyNFByb2ZpdFByb2ZpdChmaW5hbCAvIHVzZHRkZWNpbWFscyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5sb2coXCJlcnJvciB3aGlsZSBnZXR0aW5nIHN0YXRzXCIsIGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgdW5zdWI7XG4iXSwibmFtZXMiOlsiYXhpb3MiLCJkYXNoYm9hcmRTdGF0c1N0b3JlIiwidXNlQWRyZXNzU3RvcmUiLCJ1c2VVc2VySWQiLCJ1c2VVc2VyTGV2ZWxzIiwiQXBpVXJsIiwidXNkdGRlY2ltYWxzIiwidXNlUHJvZmlsZVN0b3JlIiwidXNlVXBsaW5lclN0b3JlIiwidXNlWDFMZXZlbFN0b3JlIiwidXNlWDJMZXZlbFN0b3JlIiwiZ2V0MjRIb3VyRGlyZWN0cyIsImdldDI0SG91clBheW1lbnQiLCJnZXQyNEhvdXJUZWFtQ291bnQiLCJnZXRQYXJ0bmVycyIsImdldFRvdGFsVGVhbUNvdW50IiwiaXNMb2NrZWQiLCJsYXN0VXNlcmlkIiwidXNlcnMiLCJYM2dldDI0SG91ckRpcmVjdHMiLCJYM2dldDI0SG91clBheW1lbnQiLCJYM2dldDI0SG91clRlYW1Db3VudCIsIlgzVXNlcnMiLCJnZXRTbG90RmlsbGVkIiwidW5zdWIiLCJzdWJzY3JpYmUiLCJzdGF0ZSIsImFkZHJlc3MiLCJwcmV2QWRkcmVzcyIsImNvbnNvbGUiLCJsb2ciLCJwcm9maWxlZnVuIiwiVXBsaW5lcklkIiwiZ2V0RXZlcnlMZXZlbERhdGEiLCJnZXRFdmVyeUxldmVsRGF0YVgyIiwiZ2V0RGFzaFN0YXRzIiwiZmlyZUltbWVkaWF0ZWx5IiwiY3VycmVudEFkZHJlc3MiLCJnZXRTdGF0ZSIsInNldGFwaXJlc3AiLCJzZXRyZXNwIiwiZGVmYXVsdFByb2ZpbGUiLCJpZCIsIm5hbWUiLCJwcm9maWxlSW1hZ2UiLCJkZXNjcmlwdGlvbiIsImVtYWlsIiwid2FsbGV0QWRkcmVzcyIsInNvY2lhbExpbmtzIiwiZmFjZWJvb2siLCJ5b3V0dWJlIiwiaW5zdGFncmFtIiwidHdpdHRlciIsIndoYXRzYXBwIiwicmVzcG9uc2UiLCJnZXQiLCJwcm9maWxlRGF0YSIsImRhdGEiLCJzZXRQcm9maWxlIiwid2FybiIsImVycm9yIiwic2V0VXBsaW5lcklkIiwiU2V0VXNlcklkIiwic2V0VXNlcklkIiwic2V0WDEiLCJzZXRMdmxYMSIsInNldFgyIiwic2V0THZsWDIiLCJzZXRYMyIsInNldEx2bFgzIiwic2V0VG90YWxQcm9maXQiLCJzZXRUb3RhbHBhcnRuZXJzIiwic2V0cGFydG5lcnMiLCJzZXRUb3RhbFRlYW0iLCJzZXR0ZWFtIiwic2V0aHIyNFRvdGFscGFydG5lcnMiLCJzZXRocjI0cGFydG5lcnMiLCJzZXRocjI0VG90YWxUZWFtIiwic2V0aHIyNHRlYW0iLCJ2YWwiLCJOdW1iZXIiLCJ0b1N0cmluZyIsInZhbDIiLCJYM3ZhbCIsIkthc2hpZiIsInByb2ZpdCIsInBhcnRuZXIiLCJmdW4xOCIsInBhciIsInBhcjI0IiwidGVhIiwiWDN0ZWEiLCJwYXJ0bmVyMjRociIsInRlYW0yNGhyIiwidGVhbSIsInByb2YiLCJwcm9mMiIsInNldExldmVscyIsImxldmVscyIsInVwZGF0ZWRMZXZlbHMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwibHZsIiwibGV2ZWwiLCJib29scmVzIiwic2xvdHMiLCJyZWN5Y2xlQ291bnQiLCJtYXhVc2VycyIsImxvY2tlZCIsImVyciIsInNldExldmVsc1gyIiwibGV2ZWxzWDIiLCJzZXRocjI0UHJvZml0UHJvZml0IiwidmFsWDMiLCJmaW5hbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/watchAddress.ts\n"));

/***/ })

});