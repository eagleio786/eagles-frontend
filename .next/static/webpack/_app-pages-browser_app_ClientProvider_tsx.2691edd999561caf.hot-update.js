"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_app_ClientProvider_tsx",{

/***/ "(app-pages-browser)/./store/watchAddress.ts":
/*!*******************************!*\
  !*** ./store/watchAddress.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _userCounterStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./userCounterStore */ \"(app-pages-browser)/./store/userCounterStore.ts\");\n/* harmony import */ var _config_exports__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/config/exports */ \"(app-pages-browser)/./config/exports.ts\");\n/* harmony import */ var _config_Method__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/config/Method */ \"(app-pages-browser)/./config/Method.ts\");\n// watchAddress.ts\n\n\n\n\n\n\n// ✅ Corrected subscribe\nconst unsub = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useAdressStore.subscribe((state)=>state.address, (address, prevAddress)=>{\n    if (address && address !== prevAddress) {\n        console.log(\"Address changed (global watcher):\", address);\n        profilefun();\n        UplinerId();\n        getEveryLevelData();\n        getEveryLevelDataX2();\n        getDashStats();\n    }\n}, {\n    fireImmediately: true\n});\nconst profilefun = async ()=>{\n    console.log(\"profile function is running\");\n    const currentAddress = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useAdressStore.getState().address;\n    const setapiresp = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().setresp;\n    const defaultProfile = {\n        id: \"\",\n        name: \"name\",\n        profileImage: \"\",\n        description: \"description\",\n        email: \"email@example.com\",\n        walletAddress: \"wallet_address\",\n        socialLinks: {\n            facebook: \"\",\n            youtube: \"\",\n            instagram: \"\",\n            twitter: \"\",\n            whatsapp: \"\"\n        }\n    };\n    try {\n        var _response_data;\n        const response = await axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].get(\"\".concat(_config_exports__WEBPACK_IMPORTED_MODULE_1__.ApiUrl, \"/user/profile/\").concat(currentAddress));\n        const profileData = (_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.data;\n        setapiresp(response);\n        if (profileData) {\n            _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useProfileStore.getState().setProfile(profileData);\n            console.log(\"✅ Profile updated:\", profileData);\n        } else {\n            console.warn(\"⚠️ No profile data found in response.\");\n        }\n    } catch (error) {\n        console.error(\"❌ Error while getting profile:\", error);\n        setapiresp(error);\n        _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useProfileStore.getState().setProfile(defaultProfile);\n    }\n};\nconst UplinerId = async ()=>{\n    const currentAddress = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useAdressStore.getState().address;\n    console.log(\"upliner id is \");\n    const setUplinerId = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useUplinerStore.getState().setUplinerId; // ✅ CORRECT\n    const SetUserId = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useUserId.getState().setUserId; // ✅ CORRECT\n    const setX1 = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useUserLevels.getState().setLvlX1;\n    const setX2 = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useUserLevels.getState().setLvlX2;\n    const setX3 = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useUserLevels.getState().setLvlX3;\n    const setTotalProfit = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().setTotalProfit;\n    const setTotalpartners = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().setpartners;\n    const setTotalTeam = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().setteam;\n    const sethr24Totalpartners = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().sethr24partners;\n    const sethr24TotalTeam = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().sethr24team;\n    try {\n        let val = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.users)(currentAddress);\n        SetUserId(Number(val[1]).toString());\n        setX1(Number(val[2]));\n        setX2(Number(val[3]));\n        let val2 = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.users)(val[0]);\n        let X3val = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.X3Users)(currentAddress);\n        let Kashif = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.getPartners)(currentAddress);\n        setX3(Number(X3val[2]));\n        let profit = Number(val[4]) + Number(X3val[3]);\n        let partner = Number(Kashif);\n        let fun18 = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.getTotalTeamCount)(currentAddress);\n        let par = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.get24HourDirects)(currentAddress);\n        let par24 = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.X3get24HourDirects)(currentAddress);\n        let tea = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.get24HourTeamCount)(currentAddress);\n        let X3tea = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.X3get24HourTeamCount)(currentAddress);\n        let partner24hr = Number(par) + Number(par24);\n        let team24hr = Number(tea) + Number(X3tea);\n        if (currentAddress === \"0x31eaCE9383eE97A5cF2FD6A1B254F27683DedE1B\") {\n            let team = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.lastUserid)();\n            let prof = profit / 1e18;\n            let prof2 = prof + 25418;\n            setTotalProfit(prof2);\n            setTotalTeam(Number(team) + 25445);\n            setTotalpartners(partner + 1289);\n            console.log(\"bakwas in if condition\", team, profit, prof2);\n        } else {\n            let team = Number(Kashif) + Number(fun18);\n            console.log(\"bakwas in else condition\", team);\n            setTotalTeam(team);\n            let prof = profit / 1e18;\n            setTotalProfit(prof);\n            setTotalpartners(partner);\n        }\n        sethr24TotalTeam(team24hr);\n        sethr24Totalpartners(partner24hr);\n        // setTotalProfit(profit);\n        console.log(\"upliner id is \", val2);\n        setUplinerId(Number(val2[1]).toString());\n    } catch (error) {\n        console.log(\"error while getting users data\", error);\n    }\n};\nconst setLevels = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useX1LevelStore.getState().setLevels; // ✅ FIXED\nconst levels = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useX1LevelStore.getState().levels;\nconst getEveryLevelData = async ()=>{\n    const currentAddress = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useAdressStore.getState().address;\n    try {\n        const updatedLevels = await Promise.all(levels.map(async (lvl)=>{\n            try {\n                console.log(\"response\", currentAddress);\n                const response = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.getSlotFilled)(currentAddress, \"1\", lvl.level.toString());\n                console.log(\"response\", response);\n                const boolres = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.isLocked)(currentAddress, \"1\", lvl.level.toString());\n                console.log(\"kas\", boolres);\n                return {\n                    ...lvl,\n                    slots: [\n                        Number(response[0]),\n                        lvl.slots[1]\n                    ],\n                    recycleCount: Number(response[1]),\n                    maxUsers: Number(response[0]) + Number(response[1]) * 4,\n                    locked: boolres\n                };\n            } catch (err) {\n                console.error(\"Error fetching level \".concat(lvl.level, \":\"), err);\n                return lvl;\n            }\n        }));\n        setLevels(updatedLevels);\n    } catch (error) {\n        console.log(\"Error while getting slots:\", error);\n    }\n};\nconst setLevelsX2 = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useX2LevelStore.getState().setLevels; // ✅ FIXED\nconst levelsX2 = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useX2LevelStore.getState().levels;\nconst getEveryLevelDataX2 = async ()=>{\n    const currentAddress = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useAdressStore.getState().address;\n    try {\n        const updatedLevels = await Promise.all(levelsX2.map(async (lvl)=>{\n            try {\n                console.log(\"response\", currentAddress);\n                const response = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.getSlotFilled)(currentAddress, \"2\", lvl.level.toString());\n                console.log(\"response\", response);\n                const boolres = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.isLocked)(currentAddress, \"2\", lvl.level.toString());\n                console.log(\"kas\", boolres);\n                return {\n                    ...lvl,\n                    slots: [\n                        Number(response[0]),\n                        lvl.slots[1]\n                    ],\n                    recycleCount: Number(response[1]),\n                    maxUsers: Number(response[0]) + Number(response[1]) * 4,\n                    locked: boolres\n                };\n            } catch (err) {\n                console.error(\"Error fetching level \".concat(lvl.level, \":\"), err);\n                return lvl;\n            }\n        }));\n        setLevelsX2(updatedLevels);\n    } catch (error) {\n        console.log(\"Error while getting slots:\", error);\n    }\n};\nconst getDashStats = async ()=>{\n    const currentAddress = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.useAdressStore.getState().address;\n    const sethr24ProfitProfit = _userCounterStore__WEBPACK_IMPORTED_MODULE_0__.dashboardStatsStore.getState().sethr24ProfitProfit;\n    try {\n        let val = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.get24HourPayment)(currentAddress);\n        let valX3 = await (0,_config_Method__WEBPACK_IMPORTED_MODULE_2__.X3get24HourPayment)(currentAddress);\n        let final = Number(val) + Number(valX3);\n        console.log(\"zzz\", final / _config_exports__WEBPACK_IMPORTED_MODULE_1__.usdtdecimals);\n        sethr24ProfitProfit(final / _config_exports__WEBPACK_IMPORTED_MODULE_1__.usdtdecimals);\n    } catch (error) {\n        console.log(\"error while getting stats\", error);\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unsub);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL3dhdGNoQWRkcmVzcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGtCQUFrQjtBQUNRO0FBT0U7QUFDNEI7QUFNNUI7QUFjSDtBQUN1QjtBQVVoRCx3QkFBd0I7QUFDeEIsTUFBTXdCLFFBQVF0Qiw2REFBY0EsQ0FBQ3VCLFNBQVMsQ0FDcEMsQ0FBQ0MsUUFBVUEsTUFBTUMsT0FBTyxFQUN4QixDQUFDQSxTQUFTQztJQUNSLElBQUlELFdBQVdBLFlBQVlDLGFBQWE7UUFDdENDLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUNIO1FBQ2pESTtRQUNBQztRQUNBQztRQUNBQztRQUNBQztJQUNGO0FBQ0YsR0FDQTtJQUNFQyxpQkFBaUI7QUFDbkI7QUFHRixNQUFNTCxhQUFhO0lBQ2pCRixRQUFRQyxHQUFHLENBQUM7SUFDWixNQUFNTyxpQkFBaUJuQyw2REFBY0EsQ0FBQ29DLFFBQVEsR0FBR1gsT0FBTztJQUN4RCxNQUFNWSxhQUFhdEMsa0VBQW1CQSxDQUFDcUMsUUFBUSxHQUFHRSxPQUFPO0lBRXpELE1BQU1DLGlCQUFpQjtRQUNyQkMsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLGNBQWM7UUFDZEMsYUFBYTtRQUNiQyxPQUFPO1FBQ1BDLGVBQWU7UUFDZkMsYUFBYTtZQUNYQyxVQUFVO1lBQ1ZDLFNBQVM7WUFDVEMsV0FBVztZQUNYQyxTQUFTO1lBQ1RDLFVBQVU7UUFDWjtJQUNGO0lBQ0EsSUFBSTtZQUlrQkM7UUFIcEIsTUFBTUEsV0FBVyxNQUFNdEQsNkNBQUtBLENBQUN1RCxHQUFHLENBQzlCLEdBQTBCbEIsT0FBdkJoQyxtREFBTUEsRUFBQyxrQkFBK0IsT0FBZmdDO1FBRTVCLE1BQU1tQixlQUFjRixpQkFBQUEsU0FBU0csSUFBSSxjQUFiSCxxQ0FBQUEsZUFBZUcsSUFBSTtRQUN2Q2xCLFdBQVdlO1FBRVgsSUFBSUUsYUFBYTtZQUNmakQsOERBQWVBLENBQUMrQixRQUFRLEdBQUdvQixVQUFVLENBQUNGO1lBQ3RDM0IsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQjBCO1FBQ3BDLE9BQU87WUFDTDNCLFFBQVE4QixJQUFJLENBQUM7UUFDZjtJQUNGLEVBQUUsT0FBT0MsT0FBTztRQUNkL0IsUUFBUStCLEtBQUssQ0FBQyxrQ0FBa0NBO1FBQ2hEckIsV0FBV3FCO1FBRVhyRCw4REFBZUEsQ0FBQytCLFFBQVEsR0FBR29CLFVBQVUsQ0FBQ2pCO0lBQ3hDO0FBQ0Y7QUFDQSxNQUFNVCxZQUFZO0lBQ2hCLE1BQU1LLGlCQUFpQm5DLDZEQUFjQSxDQUFDb0MsUUFBUSxHQUFHWCxPQUFPO0lBRXhERSxRQUFRQyxHQUFHLENBQUM7SUFDWixNQUFNK0IsZUFBZXJELDhEQUFlQSxDQUFDOEIsUUFBUSxHQUFHdUIsWUFBWSxFQUFFLFlBQVk7SUFDMUUsTUFBTUMsWUFBWTNELHdEQUFTQSxDQUFDbUMsUUFBUSxHQUFHeUIsU0FBUyxFQUFFLFlBQVk7SUFDOUQsTUFBTUMsUUFBUTVELDREQUFhQSxDQUFDa0MsUUFBUSxHQUFHMkIsUUFBUTtJQUMvQyxNQUFNQyxRQUFROUQsNERBQWFBLENBQUNrQyxRQUFRLEdBQUc2QixRQUFRO0lBQy9DLE1BQU1DLFFBQVFoRSw0REFBYUEsQ0FBQ2tDLFFBQVEsR0FBRytCLFFBQVE7SUFDL0MsTUFBTUMsaUJBQWlCckUsa0VBQW1CQSxDQUFDcUMsUUFBUSxHQUFHZ0MsY0FBYztJQUNwRSxNQUFNQyxtQkFBbUJ0RSxrRUFBbUJBLENBQUNxQyxRQUFRLEdBQUdrQyxXQUFXO0lBQ25FLE1BQU1DLGVBQWV4RSxrRUFBbUJBLENBQUNxQyxRQUFRLEdBQUdvQyxPQUFPO0lBQzNELE1BQU1DLHVCQUF1QjFFLGtFQUFtQkEsQ0FBQ3FDLFFBQVEsR0FBR3NDLGVBQWU7SUFDM0UsTUFBTUMsbUJBQW1CNUUsa0VBQW1CQSxDQUFDcUMsUUFBUSxHQUFHd0MsV0FBVztJQUVuRSxJQUFJO1FBQ0YsSUFBSUMsTUFBTyxNQUFNN0QscURBQUtBLENBQUNtQjtRQVN2QnlCLFVBQVVrQixPQUFPRCxHQUFHLENBQUMsRUFBRSxFQUFFRSxRQUFRO1FBQ2pDakIsTUFBTWdCLE9BQU9ELEdBQUcsQ0FBQyxFQUFFO1FBQ25CYixNQUFNYyxPQUFPRCxHQUFHLENBQUMsRUFBRTtRQUVuQixJQUFJRyxPQUFRLE1BQU1oRSxxREFBS0EsQ0FBQzZELEdBQUcsQ0FBQyxFQUFFO1FBUzlCLElBQUlJLFFBQVMsTUFBTTdELHVEQUFPQSxDQUFDZTtRQVEzQixJQUFJK0MsU0FBVSxNQUFNdEUsMkRBQVdBLENBQUN1QjtRQUNoQytCLE1BQU1ZLE9BQU9HLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLElBQUlFLFNBQVNMLE9BQU9ELEdBQUcsQ0FBQyxFQUFFLElBQUlDLE9BQU9HLEtBQUssQ0FBQyxFQUFFO1FBQzdDLElBQUlHLFVBQVVOLE9BQU9JO1FBQ3JCLElBQUlHLFFBQVEsTUFBTXhFLGlFQUFpQkEsQ0FBQ3NCO1FBQ3BDLElBQUltRCxNQUFNLE1BQU03RSxnRUFBZ0JBLENBQUMwQjtRQUNqQyxJQUFJb0QsUUFBUSxNQUFNdEUsa0VBQWtCQSxDQUFDa0I7UUFDckMsSUFBSXFELE1BQU0sTUFBTTdFLGtFQUFrQkEsQ0FBQ3dCO1FBQ25DLElBQUlzRCxRQUFRLE1BQU10RSxvRUFBb0JBLENBQUNnQjtRQUN2QyxJQUFJdUQsY0FBY1osT0FBT1EsT0FBT1IsT0FBT1M7UUFDdkMsSUFBSUksV0FBV2IsT0FBT1UsT0FBT1YsT0FBT1c7UUFDcEMsSUFBSXRELG1CQUFtQiw4Q0FBOEM7WUFDbkUsSUFBSXlELE9BQVEsTUFBTTdFLDBEQUFVQTtZQUM1QixJQUFJOEUsT0FBT1YsU0FBUztZQUNwQixJQUFJVyxRQUFRRCxPQUFPO1lBRW5CekIsZUFBZTBCO1lBQ2Z2QixhQUFhTyxPQUFPYyxRQUFRO1lBQzVCdkIsaUJBQWlCZSxVQUFVO1lBQzNCekQsUUFBUUMsR0FBRyxDQUFDLDBCQUEwQmdFLE1BQU1ULFFBQVFXO1FBQ3RELE9BQU87WUFDTCxJQUFJRixPQUFPZCxPQUFPSSxVQUFVSixPQUFPTztZQUNuQzFELFFBQVFDLEdBQUcsQ0FBQyw0QkFBNEJnRTtZQUN4Q3JCLGFBQWFxQjtZQUNiLElBQUlDLE9BQU9WLFNBQVM7WUFDcEJmLGVBQWV5QjtZQUNmeEIsaUJBQWlCZTtRQUNuQjtRQUNBVCxpQkFBaUJnQjtRQUNqQmxCLHFCQUFxQmlCO1FBRXJCLDBCQUEwQjtRQUMxQi9ELFFBQVFDLEdBQUcsQ0FBQyxrQkFBa0JvRDtRQUM5QnJCLGFBQWFtQixPQUFPRSxJQUFJLENBQUMsRUFBRSxFQUFFRCxRQUFRO0lBQ3ZDLEVBQUUsT0FBT3JCLE9BQU87UUFDZC9CLFFBQVFDLEdBQUcsQ0FBQyxrQ0FBa0M4QjtJQUNoRDtBQUNGO0FBQ0EsTUFBTXFDLFlBQVl4Riw4REFBZUEsQ0FBQzZCLFFBQVEsR0FBRzJELFNBQVMsRUFBRSxVQUFVO0FBQ2xFLE1BQU1DLFNBQVN6Riw4REFBZUEsQ0FBQzZCLFFBQVEsR0FBRzRELE1BQU07QUFFaEQsTUFBTWpFLG9CQUFvQjtJQUN4QixNQUFNSSxpQkFBaUJuQyw2REFBY0EsQ0FBQ29DLFFBQVEsR0FBR1gsT0FBTztJQUV4RCxJQUFJO1FBQ0YsTUFBTXdFLGdCQUF5QixNQUFNQyxRQUFRQyxHQUFHLENBQzlDSCxPQUFPSSxHQUFHLENBQUMsT0FBT0M7WUFDaEIsSUFBSTtnQkFDRjFFLFFBQVFDLEdBQUcsQ0FBQyxZQUFZTztnQkFDeEIsTUFBTWlCLFdBQVksTUFBTS9CLDZEQUFhQSxDQUNuQ2MsZ0JBQ0EsS0FDQWtFLElBQUlDLEtBQUssQ0FBQ3ZCLFFBQVE7Z0JBRXBCcEQsUUFBUUMsR0FBRyxDQUFDLFlBQVl3QjtnQkFDeEIsTUFBTW1ELFVBQVcsTUFBTXpGLHdEQUFRQSxDQUM3QnFCLGdCQUNBLEtBQ0FrRSxJQUFJQyxLQUFLLENBQUN2QixRQUFRO2dCQUVwQnBELFFBQVFDLEdBQUcsQ0FBQyxPQUFPMkU7Z0JBRW5CLE9BQU87b0JBQ0wsR0FBR0YsR0FBRztvQkFDTkcsT0FBTzt3QkFBQzFCLE9BQU8xQixRQUFRLENBQUMsRUFBRTt3QkFBR2lELElBQUlHLEtBQUssQ0FBQyxFQUFFO3FCQUFDO29CQUMxQ0MsY0FBYzNCLE9BQU8xQixRQUFRLENBQUMsRUFBRTtvQkFDaENzRCxVQUFVNUIsT0FBTzFCLFFBQVEsQ0FBQyxFQUFFLElBQUkwQixPQUFPMUIsUUFBUSxDQUFDLEVBQUUsSUFBSTtvQkFDdER1RCxRQUFRSjtnQkFDVjtZQUNGLEVBQUUsT0FBT0ssS0FBSztnQkFDWmpGLFFBQVErQixLQUFLLENBQUMsd0JBQWtDLE9BQVYyQyxJQUFJQyxLQUFLLEVBQUMsTUFBSU07Z0JBQ3BELE9BQU9QO1lBQ1Q7UUFDRjtRQUdGTixVQUFVRTtJQUNaLEVBQUUsT0FBT3ZDLE9BQU87UUFDZC9CLFFBQVFDLEdBQUcsQ0FBQyw4QkFBOEI4QjtJQUM1QztBQUNGO0FBQ0EsTUFBTW1ELGNBQWNyRyw4REFBZUEsQ0FBQzRCLFFBQVEsR0FBRzJELFNBQVMsRUFBRSxVQUFVO0FBQ3BFLE1BQU1lLFdBQVd0Ryw4REFBZUEsQ0FBQzRCLFFBQVEsR0FBRzRELE1BQU07QUFFbEQsTUFBTWhFLHNCQUFzQjtJQUMxQixNQUFNRyxpQkFBaUJuQyw2REFBY0EsQ0FBQ29DLFFBQVEsR0FBR1gsT0FBTztJQUV4RCxJQUFJO1FBQ0YsTUFBTXdFLGdCQUF5QixNQUFNQyxRQUFRQyxHQUFHLENBQzlDVyxTQUFTVixHQUFHLENBQUMsT0FBT0M7WUFDbEIsSUFBSTtnQkFDRjFFLFFBQVFDLEdBQUcsQ0FBQyxZQUFZTztnQkFDeEIsTUFBTWlCLFdBQVksTUFBTS9CLDZEQUFhQSxDQUNuQ2MsZ0JBQ0EsS0FDQWtFLElBQUlDLEtBQUssQ0FBQ3ZCLFFBQVE7Z0JBRXBCcEQsUUFBUUMsR0FBRyxDQUFDLFlBQVl3QjtnQkFDeEIsTUFBTW1ELFVBQVcsTUFBTXpGLHdEQUFRQSxDQUM3QnFCLGdCQUNBLEtBQ0FrRSxJQUFJQyxLQUFLLENBQUN2QixRQUFRO2dCQUVwQnBELFFBQVFDLEdBQUcsQ0FBQyxPQUFPMkU7Z0JBRW5CLE9BQU87b0JBQ0wsR0FBR0YsR0FBRztvQkFDTkcsT0FBTzt3QkFBQzFCLE9BQU8xQixRQUFRLENBQUMsRUFBRTt3QkFBR2lELElBQUlHLEtBQUssQ0FBQyxFQUFFO3FCQUFDO29CQUMxQ0MsY0FBYzNCLE9BQU8xQixRQUFRLENBQUMsRUFBRTtvQkFDaENzRCxVQUFVNUIsT0FBTzFCLFFBQVEsQ0FBQyxFQUFFLElBQUkwQixPQUFPMUIsUUFBUSxDQUFDLEVBQUUsSUFBSTtvQkFDdER1RCxRQUFRSjtnQkFDVjtZQUNGLEVBQUUsT0FBT0ssS0FBSztnQkFDWmpGLFFBQVErQixLQUFLLENBQUMsd0JBQWtDLE9BQVYyQyxJQUFJQyxLQUFLLEVBQUMsTUFBSU07Z0JBQ3BELE9BQU9QO1lBQ1Q7UUFDRjtRQUdGUSxZQUFZWjtJQUNkLEVBQUUsT0FBT3ZDLE9BQU87UUFDZC9CLFFBQVFDLEdBQUcsQ0FBQyw4QkFBOEI4QjtJQUM1QztBQUNGO0FBRUEsTUFBTXpCLGVBQWU7SUFDbkIsTUFBTUUsaUJBQWlCbkMsNkRBQWNBLENBQUNvQyxRQUFRLEdBQUdYLE9BQU87SUFDeEQsTUFBTXNGLHNCQUNKaEgsa0VBQW1CQSxDQUFDcUMsUUFBUSxHQUFHMkUsbUJBQW1CO0lBQ3BELElBQUk7UUFDRixJQUFJbEMsTUFBTSxNQUFNbkUsZ0VBQWdCQSxDQUFDeUI7UUFDakMsSUFBSTZFLFFBQVEsTUFBTTlGLGtFQUFrQkEsQ0FBQ2lCO1FBQ3JDLElBQUk4RSxRQUFRbkMsT0FBT0QsT0FBT0MsT0FBT2tDO1FBQ2pDckYsUUFBUUMsR0FBRyxDQUFDLE9BQU9xRixRQUFRN0cseURBQVlBO1FBRXZDMkcsb0JBQW9CRSxRQUFRN0cseURBQVlBO0lBQzFDLEVBQUUsT0FBT3NELE9BQU87UUFDZC9CLFFBQVFDLEdBQUcsQ0FBQyw2QkFBNkI4QjtJQUMzQztBQUNGO0FBRUEsaUVBQWVwQyxLQUFLQSxFQUFDIiwic291cmNlcyI6WyIvaG9tZS9rYXNoaWYvRG9jdW1lbnRzL2thc2hpZi9kZXBsb3ltZW50L2VhZ2xlcy1mcm9udGVuZC9zdG9yZS93YXRjaEFkZHJlc3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gd2F0Y2hBZGRyZXNzLnRzXG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQge1xuICBkYXNoYm9hcmRTdGF0c1N0b3JlLFxuICB1c2VBZHJlc3NTdG9yZSxcbiAgdXNlU3RhdHNTdG9yZSxcbiAgdXNlVXNlcklkLFxuICB1c2VVc2VyTGV2ZWxzLFxufSBmcm9tIFwiLi91c2VyQ291bnRlclN0b3JlXCI7XG5pbXBvcnQgeyBBcGlVcmwsIHVzZHRkZWNpbWFscyB9IGZyb20gXCJAL2NvbmZpZy9leHBvcnRzXCI7XG5pbXBvcnQge1xuICB1c2VQcm9maWxlU3RvcmUsXG4gIHVzZVVwbGluZXJTdG9yZSxcbiAgdXNlWDFMZXZlbFN0b3JlLFxuICB1c2VYMkxldmVsU3RvcmUsXG59IGZyb20gXCIuL3VzZXJDb3VudGVyU3RvcmVcIjtcbmltcG9ydCB7XG4gIGdldDI0SG91ckRpcmVjdHMsXG4gIGdldDI0SG91clBheW1lbnQsXG4gIGdldDI0SG91clRlYW1Db3VudCxcbiAgZ2V0UGFydG5lcnMsXG4gIGdldFRvdGFsVGVhbUNvdW50LFxuICBpc0xvY2tlZCxcbiAgbGFzdFVzZXJpZCxcbiAgdXNlcnMsXG4gIFgzZ2V0MjRIb3VyRGlyZWN0cyxcbiAgWDNnZXQyNEhvdXJQYXltZW50LFxuICBYM2dldDI0SG91clRlYW1Db3VudCxcbiAgWDNVc2Vycyxcbn0gZnJvbSBcIkAvY29uZmlnL01ldGhvZFwiO1xuaW1wb3J0IHsgZ2V0U2xvdEZpbGxlZCB9IGZyb20gXCJAL2NvbmZpZy9NZXRob2RcIjtcbmludGVyZmFjZSBMZXZlbCB7XG4gIGxldmVsOiBudW1iZXI7XG4gIGNvc3Q6IG51bWJlcjtcbiAgc2xvdHM6IFtudW1iZXIsIG51bWJlcl07IC8vIFtmaWxsZWQsIHJlY3ljbGVkXVxuICBtYXhVc2VyczogbnVtYmVyO1xuICByZWN5Y2xlQ291bnQ6IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICBsb2NrZWQ6IGJvb2xlYW47XG59XG4vLyDinIUgQ29ycmVjdGVkIHN1YnNjcmliZVxuY29uc3QgdW5zdWIgPSB1c2VBZHJlc3NTdG9yZS5zdWJzY3JpYmUoXG4gIChzdGF0ZSkgPT4gc3RhdGUuYWRkcmVzcyxcbiAgKGFkZHJlc3MsIHByZXZBZGRyZXNzKSA9PiB7XG4gICAgaWYgKGFkZHJlc3MgJiYgYWRkcmVzcyAhPT0gcHJldkFkZHJlc3MpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiQWRkcmVzcyBjaGFuZ2VkIChnbG9iYWwgd2F0Y2hlcik6XCIsIGFkZHJlc3MpO1xuICAgICAgcHJvZmlsZWZ1bigpO1xuICAgICAgVXBsaW5lcklkKCk7XG4gICAgICBnZXRFdmVyeUxldmVsRGF0YSgpO1xuICAgICAgZ2V0RXZlcnlMZXZlbERhdGFYMigpO1xuICAgICAgZ2V0RGFzaFN0YXRzKCk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgZmlyZUltbWVkaWF0ZWx5OiB0cnVlLCAvLyBydW4gb24gZmlyc3QgbG9hZCBpZiB2YWx1ZSBpcyBub24tbnVsbFxuICB9XG4pO1xuXG5jb25zdCBwcm9maWxlZnVuID0gYXN5bmMgKCkgPT4ge1xuICBjb25zb2xlLmxvZyhcInByb2ZpbGUgZnVuY3Rpb24gaXMgcnVubmluZ1wiKTtcbiAgY29uc3QgY3VycmVudEFkZHJlc3MgPSB1c2VBZHJlc3NTdG9yZS5nZXRTdGF0ZSgpLmFkZHJlc3M7XG4gIGNvbnN0IHNldGFwaXJlc3AgPSBkYXNoYm9hcmRTdGF0c1N0b3JlLmdldFN0YXRlKCkuc2V0cmVzcDtcblxuICBjb25zdCBkZWZhdWx0UHJvZmlsZSA9IHtcbiAgICBpZDogXCJcIixcbiAgICBuYW1lOiBcIm5hbWVcIixcbiAgICBwcm9maWxlSW1hZ2U6IFwiXCIsXG4gICAgZGVzY3JpcHRpb246IFwiZGVzY3JpcHRpb25cIixcbiAgICBlbWFpbDogXCJlbWFpbEBleGFtcGxlLmNvbVwiLFxuICAgIHdhbGxldEFkZHJlc3M6IFwid2FsbGV0X2FkZHJlc3NcIixcbiAgICBzb2NpYWxMaW5rczoge1xuICAgICAgZmFjZWJvb2s6IFwiXCIsXG4gICAgICB5b3V0dWJlOiBcIlwiLFxuICAgICAgaW5zdGFncmFtOiBcIlwiLFxuICAgICAgdHdpdHRlcjogXCJcIixcbiAgICAgIHdoYXRzYXBwOiBcIlwiLFxuICAgIH0sXG4gIH07XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoXG4gICAgICBgJHtBcGlVcmx9L3VzZXIvcHJvZmlsZS8ke2N1cnJlbnRBZGRyZXNzfWBcbiAgICApO1xuICAgIGNvbnN0IHByb2ZpbGVEYXRhID0gcmVzcG9uc2UuZGF0YT8uZGF0YTtcbiAgICBzZXRhcGlyZXNwKHJlc3BvbnNlIGFzIGFueSk7XG4gICAgXG4gICAgaWYgKHByb2ZpbGVEYXRhKSB7XG4gICAgICB1c2VQcm9maWxlU3RvcmUuZ2V0U3RhdGUoKS5zZXRQcm9maWxlKHByb2ZpbGVEYXRhKTtcbiAgICAgIGNvbnNvbGUubG9nKFwi4pyFIFByb2ZpbGUgdXBkYXRlZDpcIiwgcHJvZmlsZURhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gcHJvZmlsZSBkYXRhIGZvdW5kIGluIHJlc3BvbnNlLlwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciB3aGlsZSBnZXR0aW5nIHByb2ZpbGU6XCIsIGVycm9yKTtcbiAgICBzZXRhcGlyZXNwKGVycm9yIGFzIGFueSk7XG5cbiAgICB1c2VQcm9maWxlU3RvcmUuZ2V0U3RhdGUoKS5zZXRQcm9maWxlKGRlZmF1bHRQcm9maWxlKTtcbiAgfVxufTtcbmNvbnN0IFVwbGluZXJJZCA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgY3VycmVudEFkZHJlc3MgPSB1c2VBZHJlc3NTdG9yZS5nZXRTdGF0ZSgpLmFkZHJlc3M7XG5cbiAgY29uc29sZS5sb2coXCJ1cGxpbmVyIGlkIGlzIFwiKTtcbiAgY29uc3Qgc2V0VXBsaW5lcklkID0gdXNlVXBsaW5lclN0b3JlLmdldFN0YXRlKCkuc2V0VXBsaW5lcklkOyAvLyDinIUgQ09SUkVDVFxuICBjb25zdCBTZXRVc2VySWQgPSB1c2VVc2VySWQuZ2V0U3RhdGUoKS5zZXRVc2VySWQ7IC8vIOKchSBDT1JSRUNUXG4gIGNvbnN0IHNldFgxID0gdXNlVXNlckxldmVscy5nZXRTdGF0ZSgpLnNldEx2bFgxO1xuICBjb25zdCBzZXRYMiA9IHVzZVVzZXJMZXZlbHMuZ2V0U3RhdGUoKS5zZXRMdmxYMjtcbiAgY29uc3Qgc2V0WDMgPSB1c2VVc2VyTGV2ZWxzLmdldFN0YXRlKCkuc2V0THZsWDM7XG4gIGNvbnN0IHNldFRvdGFsUHJvZml0ID0gZGFzaGJvYXJkU3RhdHNTdG9yZS5nZXRTdGF0ZSgpLnNldFRvdGFsUHJvZml0O1xuICBjb25zdCBzZXRUb3RhbHBhcnRuZXJzID0gZGFzaGJvYXJkU3RhdHNTdG9yZS5nZXRTdGF0ZSgpLnNldHBhcnRuZXJzO1xuICBjb25zdCBzZXRUb3RhbFRlYW0gPSBkYXNoYm9hcmRTdGF0c1N0b3JlLmdldFN0YXRlKCkuc2V0dGVhbTtcbiAgY29uc3Qgc2V0aHIyNFRvdGFscGFydG5lcnMgPSBkYXNoYm9hcmRTdGF0c1N0b3JlLmdldFN0YXRlKCkuc2V0aHIyNHBhcnRuZXJzO1xuICBjb25zdCBzZXRocjI0VG90YWxUZWFtID0gZGFzaGJvYXJkU3RhdHNTdG9yZS5nZXRTdGF0ZSgpLnNldGhyMjR0ZWFtO1xuXG4gIHRyeSB7XG4gICAgbGV0IHZhbCA9IChhd2FpdCB1c2VycyhjdXJyZW50QWRkcmVzcykpIGFzIFtcbiAgICAgIHN0cmluZyxcbiAgICAgIEJpZ0ludCxcbiAgICAgIEJpZ0ludCxcbiAgICAgIEJpZ0ludCxcbiAgICAgIEJpZ0ludCxcbiAgICAgIEJpZ0ludCxcbiAgICAgIEJpZ0ludFxuICAgIF07XG4gICAgU2V0VXNlcklkKE51bWJlcih2YWxbMV0pLnRvU3RyaW5nKCkpO1xuICAgIHNldFgxKE51bWJlcih2YWxbMl0pKTtcbiAgICBzZXRYMihOdW1iZXIodmFsWzNdKSk7XG5cbiAgICBsZXQgdmFsMiA9IChhd2FpdCB1c2Vycyh2YWxbMF0pKSBhcyBbXG4gICAgICBzdHJpbmcsXG4gICAgICBCaWdJbnQsXG4gICAgICBCaWdJbnQsXG4gICAgICBCaWdJbnQsXG4gICAgICBCaWdJbnQsXG4gICAgICBCaWdJbnQsXG4gICAgICBCaWdJbnRcbiAgICBdO1xuICAgIGxldCBYM3ZhbCA9IChhd2FpdCBYM1VzZXJzKGN1cnJlbnRBZGRyZXNzKSkgYXMgW1xuICAgICAgc3RyaW5nLFxuICAgICAgQmlnSW50LFxuICAgICAgQmlnSW50LFxuICAgICAgQmlnSW50LFxuICAgICAgQmlnSW50LFxuICAgICAgQmlnSW50XG4gICAgXTtcbiAgICBsZXQgS2FzaGlmID0gKGF3YWl0IGdldFBhcnRuZXJzKGN1cnJlbnRBZGRyZXNzKSkgYXMgbnVtYmVyO1xuICAgIHNldFgzKE51bWJlcihYM3ZhbFsyXSkpO1xuICAgIGxldCBwcm9maXQgPSBOdW1iZXIodmFsWzRdKSArIE51bWJlcihYM3ZhbFszXSk7XG4gICAgbGV0IHBhcnRuZXIgPSBOdW1iZXIoS2FzaGlmKTtcbiAgICBsZXQgZnVuMTggPSBhd2FpdCBnZXRUb3RhbFRlYW1Db3VudChjdXJyZW50QWRkcmVzcyk7XG4gICAgbGV0IHBhciA9IGF3YWl0IGdldDI0SG91ckRpcmVjdHMoY3VycmVudEFkZHJlc3MpO1xuICAgIGxldCBwYXIyNCA9IGF3YWl0IFgzZ2V0MjRIb3VyRGlyZWN0cyhjdXJyZW50QWRkcmVzcyk7XG4gICAgbGV0IHRlYSA9IGF3YWl0IGdldDI0SG91clRlYW1Db3VudChjdXJyZW50QWRkcmVzcyk7XG4gICAgbGV0IFgzdGVhID0gYXdhaXQgWDNnZXQyNEhvdXJUZWFtQ291bnQoY3VycmVudEFkZHJlc3MpO1xuICAgIGxldCBwYXJ0bmVyMjRociA9IE51bWJlcihwYXIpICsgTnVtYmVyKHBhcjI0KTtcbiAgICBsZXQgdGVhbTI0aHIgPSBOdW1iZXIodGVhKSArIE51bWJlcihYM3RlYSk7XG4gICAgaWYgKGN1cnJlbnRBZGRyZXNzID09PSBcIjB4MzFlYUNFOTM4M2VFOTdBNWNGMkZENkExQjI1NEYyNzY4M0RlZEUxQlwiKSB7XG4gICAgICBsZXQgdGVhbSA9IChhd2FpdCBsYXN0VXNlcmlkKCkpIGFzIGJpZ2ludDtcbiAgICAgIGxldCBwcm9mID0gcHJvZml0IC8gMWUxODtcbiAgICAgIGxldCBwcm9mMiA9IHByb2YgKyAyNTQxODtcblxuICAgICAgc2V0VG90YWxQcm9maXQocHJvZjIpO1xuICAgICAgc2V0VG90YWxUZWFtKE51bWJlcih0ZWFtKSArIDI1NDQ1KTtcbiAgICAgIHNldFRvdGFscGFydG5lcnMocGFydG5lciArIDEyODkpO1xuICAgICAgY29uc29sZS5sb2coXCJiYWt3YXMgaW4gaWYgY29uZGl0aW9uXCIsIHRlYW0sIHByb2ZpdCwgcHJvZjIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdGVhbSA9IE51bWJlcihLYXNoaWYpICsgTnVtYmVyKGZ1bjE4KTtcbiAgICAgIGNvbnNvbGUubG9nKFwiYmFrd2FzIGluIGVsc2UgY29uZGl0aW9uXCIsIHRlYW0pO1xuICAgICAgc2V0VG90YWxUZWFtKHRlYW0pO1xuICAgICAgbGV0IHByb2YgPSBwcm9maXQgLyAxZTE4O1xuICAgICAgc2V0VG90YWxQcm9maXQocHJvZik7XG4gICAgICBzZXRUb3RhbHBhcnRuZXJzKHBhcnRuZXIpO1xuICAgIH1cbiAgICBzZXRocjI0VG90YWxUZWFtKHRlYW0yNGhyKTtcbiAgICBzZXRocjI0VG90YWxwYXJ0bmVycyhwYXJ0bmVyMjRocik7XG5cbiAgICAvLyBzZXRUb3RhbFByb2ZpdChwcm9maXQpO1xuICAgIGNvbnNvbGUubG9nKFwidXBsaW5lciBpZCBpcyBcIiwgdmFsMik7XG4gICAgc2V0VXBsaW5lcklkKE51bWJlcih2YWwyWzFdKS50b1N0cmluZygpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZyhcImVycm9yIHdoaWxlIGdldHRpbmcgdXNlcnMgZGF0YVwiLCBlcnJvcik7XG4gIH1cbn07XG5jb25zdCBzZXRMZXZlbHMgPSB1c2VYMUxldmVsU3RvcmUuZ2V0U3RhdGUoKS5zZXRMZXZlbHM7IC8vIOKchSBGSVhFRFxuY29uc3QgbGV2ZWxzID0gdXNlWDFMZXZlbFN0b3JlLmdldFN0YXRlKCkubGV2ZWxzO1xuXG5jb25zdCBnZXRFdmVyeUxldmVsRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgY3VycmVudEFkZHJlc3MgPSB1c2VBZHJlc3NTdG9yZS5nZXRTdGF0ZSgpLmFkZHJlc3M7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB1cGRhdGVkTGV2ZWxzOiBMZXZlbFtdID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBsZXZlbHMubWFwKGFzeW5jIChsdmwpOiBQcm9taXNlPExldmVsPiA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJyZXNwb25zZVwiLCBjdXJyZW50QWRkcmVzcyk7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgZ2V0U2xvdEZpbGxlZChcbiAgICAgICAgICAgIGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICAgICAgXCIxXCIsXG4gICAgICAgICAgICBsdmwubGV2ZWwudG9TdHJpbmcoKVxuICAgICAgICAgICkpIGFzIFtiaWdpbnQsIGJpZ2ludF07XG4gICAgICAgICAgY29uc29sZS5sb2coXCJyZXNwb25zZVwiLCByZXNwb25zZSk7XG4gICAgICAgICAgY29uc3QgYm9vbHJlcyA9IChhd2FpdCBpc0xvY2tlZChcbiAgICAgICAgICAgIGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICAgICAgXCIxXCIsXG4gICAgICAgICAgICBsdmwubGV2ZWwudG9TdHJpbmcoKVxuICAgICAgICAgICkpIGFzIGJvb2xlYW47XG4gICAgICAgICAgY29uc29sZS5sb2coXCJrYXNcIiwgYm9vbHJlcyk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubHZsLFxuICAgICAgICAgICAgc2xvdHM6IFtOdW1iZXIocmVzcG9uc2VbMF0pLCBsdmwuc2xvdHNbMV1dIGFzIFtudW1iZXIsIG51bWJlcl0sIC8vIPCfkYggZml4IGhlcmVcbiAgICAgICAgICAgIHJlY3ljbGVDb3VudDogTnVtYmVyKHJlc3BvbnNlWzFdKSxcbiAgICAgICAgICAgIG1heFVzZXJzOiBOdW1iZXIocmVzcG9uc2VbMF0pICsgTnVtYmVyKHJlc3BvbnNlWzFdKSAqIDQsXG4gICAgICAgICAgICBsb2NrZWQ6IGJvb2xyZXMsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbGV2ZWwgJHtsdmwubGV2ZWx9OmAsIGVycik7XG4gICAgICAgICAgcmV0dXJuIGx2bDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgc2V0TGV2ZWxzKHVwZGF0ZWRMZXZlbHMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUubG9nKFwiRXJyb3Igd2hpbGUgZ2V0dGluZyBzbG90czpcIiwgZXJyb3IpO1xuICB9XG59O1xuY29uc3Qgc2V0TGV2ZWxzWDIgPSB1c2VYMkxldmVsU3RvcmUuZ2V0U3RhdGUoKS5zZXRMZXZlbHM7IC8vIOKchSBGSVhFRFxuY29uc3QgbGV2ZWxzWDIgPSB1c2VYMkxldmVsU3RvcmUuZ2V0U3RhdGUoKS5sZXZlbHM7XG5cbmNvbnN0IGdldEV2ZXJ5TGV2ZWxEYXRhWDIgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRBZGRyZXNzID0gdXNlQWRyZXNzU3RvcmUuZ2V0U3RhdGUoKS5hZGRyZXNzO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgdXBkYXRlZExldmVsczogTGV2ZWxbXSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgbGV2ZWxzWDIubWFwKGFzeW5jIChsdmwpOiBQcm9taXNlPExldmVsPiA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJyZXNwb25zZVwiLCBjdXJyZW50QWRkcmVzcyk7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgZ2V0U2xvdEZpbGxlZChcbiAgICAgICAgICAgIGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICAgICAgXCIyXCIsXG4gICAgICAgICAgICBsdmwubGV2ZWwudG9TdHJpbmcoKVxuICAgICAgICAgICkpIGFzIFtiaWdpbnQsIGJpZ2ludF07XG4gICAgICAgICAgY29uc29sZS5sb2coXCJyZXNwb25zZVwiLCByZXNwb25zZSk7XG4gICAgICAgICAgY29uc3QgYm9vbHJlcyA9IChhd2FpdCBpc0xvY2tlZChcbiAgICAgICAgICAgIGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICAgICAgXCIyXCIsXG4gICAgICAgICAgICBsdmwubGV2ZWwudG9TdHJpbmcoKVxuICAgICAgICAgICkpIGFzIGJvb2xlYW47XG4gICAgICAgICAgY29uc29sZS5sb2coXCJrYXNcIiwgYm9vbHJlcyk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubHZsLFxuICAgICAgICAgICAgc2xvdHM6IFtOdW1iZXIocmVzcG9uc2VbMF0pLCBsdmwuc2xvdHNbMV1dIGFzIFtudW1iZXIsIG51bWJlcl0sIC8vIPCfkYggZml4IGhlcmVcbiAgICAgICAgICAgIHJlY3ljbGVDb3VudDogTnVtYmVyKHJlc3BvbnNlWzFdKSxcbiAgICAgICAgICAgIG1heFVzZXJzOiBOdW1iZXIocmVzcG9uc2VbMF0pICsgTnVtYmVyKHJlc3BvbnNlWzFdKSAqIDQsXG4gICAgICAgICAgICBsb2NrZWQ6IGJvb2xyZXMsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbGV2ZWwgJHtsdmwubGV2ZWx9OmAsIGVycik7XG4gICAgICAgICAgcmV0dXJuIGx2bDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgc2V0TGV2ZWxzWDIodXBkYXRlZExldmVscyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5sb2coXCJFcnJvciB3aGlsZSBnZXR0aW5nIHNsb3RzOlwiLCBlcnJvcik7XG4gIH1cbn07XG5cbmNvbnN0IGdldERhc2hTdGF0cyA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgY3VycmVudEFkZHJlc3MgPSB1c2VBZHJlc3NTdG9yZS5nZXRTdGF0ZSgpLmFkZHJlc3M7XG4gIGNvbnN0IHNldGhyMjRQcm9maXRQcm9maXQgPVxuICAgIGRhc2hib2FyZFN0YXRzU3RvcmUuZ2V0U3RhdGUoKS5zZXRocjI0UHJvZml0UHJvZml0O1xuICB0cnkge1xuICAgIGxldCB2YWwgPSBhd2FpdCBnZXQyNEhvdXJQYXltZW50KGN1cnJlbnRBZGRyZXNzKTtcbiAgICBsZXQgdmFsWDMgPSBhd2FpdCBYM2dldDI0SG91clBheW1lbnQoY3VycmVudEFkZHJlc3MpO1xuICAgIGxldCBmaW5hbCA9IE51bWJlcih2YWwpICsgTnVtYmVyKHZhbFgzKTtcbiAgICBjb25zb2xlLmxvZyhcInp6elwiLCBmaW5hbCAvIHVzZHRkZWNpbWFscyk7XG5cbiAgICBzZXRocjI0UHJvZml0UHJvZml0KGZpbmFsIC8gdXNkdGRlY2ltYWxzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZyhcImVycm9yIHdoaWxlIGdldHRpbmcgc3RhdHNcIiwgZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1bnN1YjtcbiJdLCJuYW1lcyI6WyJheGlvcyIsImRhc2hib2FyZFN0YXRzU3RvcmUiLCJ1c2VBZHJlc3NTdG9yZSIsInVzZVVzZXJJZCIsInVzZVVzZXJMZXZlbHMiLCJBcGlVcmwiLCJ1c2R0ZGVjaW1hbHMiLCJ1c2VQcm9maWxlU3RvcmUiLCJ1c2VVcGxpbmVyU3RvcmUiLCJ1c2VYMUxldmVsU3RvcmUiLCJ1c2VYMkxldmVsU3RvcmUiLCJnZXQyNEhvdXJEaXJlY3RzIiwiZ2V0MjRIb3VyUGF5bWVudCIsImdldDI0SG91clRlYW1Db3VudCIsImdldFBhcnRuZXJzIiwiZ2V0VG90YWxUZWFtQ291bnQiLCJpc0xvY2tlZCIsImxhc3RVc2VyaWQiLCJ1c2VycyIsIlgzZ2V0MjRIb3VyRGlyZWN0cyIsIlgzZ2V0MjRIb3VyUGF5bWVudCIsIlgzZ2V0MjRIb3VyVGVhbUNvdW50IiwiWDNVc2VycyIsImdldFNsb3RGaWxsZWQiLCJ1bnN1YiIsInN1YnNjcmliZSIsInN0YXRlIiwiYWRkcmVzcyIsInByZXZBZGRyZXNzIiwiY29uc29sZSIsImxvZyIsInByb2ZpbGVmdW4iLCJVcGxpbmVySWQiLCJnZXRFdmVyeUxldmVsRGF0YSIsImdldEV2ZXJ5TGV2ZWxEYXRhWDIiLCJnZXREYXNoU3RhdHMiLCJmaXJlSW1tZWRpYXRlbHkiLCJjdXJyZW50QWRkcmVzcyIsImdldFN0YXRlIiwic2V0YXBpcmVzcCIsInNldHJlc3AiLCJkZWZhdWx0UHJvZmlsZSIsImlkIiwibmFtZSIsInByb2ZpbGVJbWFnZSIsImRlc2NyaXB0aW9uIiwiZW1haWwiLCJ3YWxsZXRBZGRyZXNzIiwic29jaWFsTGlua3MiLCJmYWNlYm9vayIsInlvdXR1YmUiLCJpbnN0YWdyYW0iLCJ0d2l0dGVyIiwid2hhdHNhcHAiLCJyZXNwb25zZSIsImdldCIsInByb2ZpbGVEYXRhIiwiZGF0YSIsInNldFByb2ZpbGUiLCJ3YXJuIiwiZXJyb3IiLCJzZXRVcGxpbmVySWQiLCJTZXRVc2VySWQiLCJzZXRVc2VySWQiLCJzZXRYMSIsInNldEx2bFgxIiwic2V0WDIiLCJzZXRMdmxYMiIsInNldFgzIiwic2V0THZsWDMiLCJzZXRUb3RhbFByb2ZpdCIsInNldFRvdGFscGFydG5lcnMiLCJzZXRwYXJ0bmVycyIsInNldFRvdGFsVGVhbSIsInNldHRlYW0iLCJzZXRocjI0VG90YWxwYXJ0bmVycyIsInNldGhyMjRwYXJ0bmVycyIsInNldGhyMjRUb3RhbFRlYW0iLCJzZXRocjI0dGVhbSIsInZhbCIsIk51bWJlciIsInRvU3RyaW5nIiwidmFsMiIsIlgzdmFsIiwiS2FzaGlmIiwicHJvZml0IiwicGFydG5lciIsImZ1bjE4IiwicGFyIiwicGFyMjQiLCJ0ZWEiLCJYM3RlYSIsInBhcnRuZXIyNGhyIiwidGVhbTI0aHIiLCJ0ZWFtIiwicHJvZiIsInByb2YyIiwic2V0TGV2ZWxzIiwibGV2ZWxzIiwidXBkYXRlZExldmVscyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJsdmwiLCJsZXZlbCIsImJvb2xyZXMiLCJzbG90cyIsInJlY3ljbGVDb3VudCIsIm1heFVzZXJzIiwibG9ja2VkIiwiZXJyIiwic2V0TGV2ZWxzWDIiLCJsZXZlbHNYMiIsInNldGhyMjRQcm9maXRQcm9maXQiLCJ2YWxYMyIsImZpbmFsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/watchAddress.ts\n"));

/***/ })

});